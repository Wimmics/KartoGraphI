{"mappings":"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","sources":["src/index.ts","src/DataCaching.ts","src/GlobalUtils.ts","src/LogUtils.ts","src/SparqlUtils.ts","src/RDFUtils.ts","src/EChartsDataCaching.ts","src/ChartsUtils.ts"],"sourcesContent":["import * as DataCache from './DataCaching';\nimport * as Logger from './LogUtils';\nimport * as EChartsCache from './EChartsDataCaching';\n\nDataCache.runsetList.then(runsetObjectList => {\n    return DataCache.retrieveKnownVocabularies().then(() => {\n        return DataCache.allVocabFill().then(() => {\n            return Promise.allSettled(\n                runsetObjectList.map((runsetObject) => {\n                    return Promise.allSettled([\n                        DataCache.endpointMapfill(runsetObject),\n\n                        DataCache.tripleDataFill(runsetObject).then(() =>\n                            EChartsCache.triplesEchartsOption(runsetObject.id)\n                        ),\n                        DataCache.classDataFill(runsetObject).then(() =>\n                            EChartsCache.classesEchartsOption(runsetObject.id)\n                        ),\n                        DataCache.propertyDataFill(runsetObject).then(() =>\n                            EChartsCache.propertiesEchartsOption(runsetObject.id)\n                        ),\n                        DataCache.shortUrisDataFill(runsetObject).then(() =>\n                            EChartsCache.shortUrisEchartsOption(runsetObject.id)\n                        ),\n                        DataCache.rdfDataStructureDataFill(runsetObject).then(() =>\n                            EChartsCache.rdfDataStructuresEchartsOption(runsetObject.id)\n                        ),\n                        DataCache.readableLabelsDataFill(runsetObject).then(() =>\n                            EChartsCache.readableLabelsEchartsOption(runsetObject.id)\n                        ),\n                        DataCache.blankNodeDataFill(runsetObject).then(() =>\n                            EChartsCache.blankNodesEchartsOption(runsetObject.id)\n                        ),\n                        DataCache.SPARQLCoverageFill(runsetObject).then(() =>\n                            EChartsCache.sparqlCoverageEchartsOption(runsetObject.id)\n                        ),\n                        DataCache.vocabFill(runsetObject).then(() =>\n                            Promise.allSettled([\n                                EChartsCache.endpointVocabsGraphEchartsOption(runsetObject.id),\n                                EChartsCache.endpointKeywordsGraphEchartsOption(runsetObject.id),\n                                EChartsCache.endpointStandardVocabulariesGraphEchartsOption(runsetObject.id)\n                            ])\n                        ),\n                        DataCache.datasetDescriptionDataFill(runsetObject).then(() =>\n                            EChartsCache.datasetDescriptionEchartsOption(runsetObject.id)\n                        ),\n\n                        // DataCache.classAndPropertiesDataFill(runsetObject), // Pas de charts et trs long\n\n                        // DataCache.totalRuntimeDataFill(runsetObject), // A supprimer du site\n                        // DataCache.averageRuntimeDataFill(), // A supprimer du site\n                        // DataCache.categoryTestCountFill(), // A supprimer du site // Pas OK\n                        // DataCache.totalCategoryTestCountFill(), // A supprimer du site // Pas OK\n                        // DataCache.endpointTestsDataFill(), // A supprimer du site\n                    ])\n                })\n            )\n        })\n    })\n})\n    .catch(error => {\n        Logger.error(error)\n    });","import * as fs from 'node:fs';\nimport * as $rdf from \"rdflib\";\nimport dayjs, { Dayjs } from \"dayjs\";\nimport duration from 'dayjs/plugin/duration.js';\nimport customParseFormat from 'dayjs/plugin/customParseFormat.js';\nimport relativeTime from 'dayjs/plugin/relativeTime.js';\ndayjs.extend(duration);\ndayjs.extend(relativeTime)\ndayjs.extend(customParseFormat)\ndayjs.extend(duration)\nimport md5 from 'md5';\nimport * as Global from \"./GlobalUtils\";\nimport * as Logger from \"./LogUtils\";\nimport * as Sparql from \"./SparqlUtils\";\nimport * as RDFUtils from \"./RDFUtils\";\nimport { ClassCountDataObject, EndpointIpGeolocObject, EndpointItem, EndpointTestObject, JSONValue, KeywordsEndpointDataObject, RunSetObject, SPARQLJSONResult, TimezoneMapObject, TripleCountDataObject, VocabEndpointDataObject } from './DataTypes';\n\nconst dataFilePrefix = \"./data/\";\nexport const dataCachedFilePrefix = \"./data/cache/\";\nexport const runsetList = Global.readJSONFile(dataFilePrefix + 'runSets.json') as Promise<RunSetObject[]>;\nconst timezoneMap = Global.readJSONFile(dataFilePrefix + 'timezoneMap.json');\nconst endpointIpMap = Global.readJSONFile(dataFilePrefix + 'endpointIpGeoloc.json');\n\nexport const geolocFilename = \"geolocData\";\nexport const sparqlCoverageFilename = \"sparqlCoverageData\";\nexport const sparqlFeaturesFilename = \"sparqlFeaturesData\";\nexport const vocabEndpointFilename = \"vocabEndpointData\";\n// export const knownVocabsFilename = \"knownVocabsData\";\nexport const endpointKeywordsFilename = \"endpointKeywordsData\";\nexport const tripleCountFilename = \"tripleCountData\";\nexport const classCountFilename = \"classCountData\";\nexport const propertyCountFilename = \"propertyCountData\";\nexport const categoryTestCountFilename = \"categoryTestCountData\";\nexport const totalCategoryTestCountFilename = \"totalCategoryTestCountData\";\nexport const endpointTestsDataFilename = \"endpointTestsData\";\nexport const totalRuntimeDataFilename = \"totalRuntimeData\";\nexport const averageRuntimeDataFilename = \"averageRuntimeData\";\nexport const classPropertyDataFilename = \"classPropertyData\";\nexport const datasetDescriptionDataFilename = \"datasetDescriptionData\";\nexport const shortUriDataFilename = \"shortUriData\";\nexport const rdfDataStructureDataFilename = \"rdfDataStructureData\";\nexport const readableLabelDataFilename = \"readableLabelData\";\nexport const blankNodesDataFilename = \"blankNodesData\";\n\nexport const LOVFilename = dataFilePrefix + \"knownVocabulariesLOV.json\"\nlet knownVocabularies = new Set();\n\n\n// https://obofoundry.org/ // No ontology URL available in ontology description\n// http://prefix.cc/context // done\n// http://data.bioontology.org/resource_index/resources?apikey=b86b12d8-dc46-4528-82e3-13fbdabf5191 // No ontology URL available in ontology description\n// https://lov.linkeddata.es/dataset/lov/api/v2/vocabulary/list // done\n\n// Retrieval of the list of LOV vocabularies to filter the ones retrieved in the index\nexport function retrieveKnownVocabularies() {\n    return Global.fetchJSONPromise(\"https://lov.linkeddata.es/dataset/lov/api/v2/vocabulary/list\")\n        .then(responseLOV => {\n            if (responseLOV !== undefined) {\n                (responseLOV as JSONValue[]).forEach((item) => {\n                    knownVocabularies.add(item[\"uri\"])\n                });\n                try {\n                    let content = JSON.stringify(responseLOV);\n                    return Global.writeFile(LOVFilename, content).then(() => {\n                        return Promise.resolve(knownVocabularies);\n                    });\n                } catch (err) {\n                    Logger.error(err)\n                    return Promise.reject(err);\n                }\n            } else {\n                return Promise.reject(\"LOV response is undefined\");\n            }\n        })\n        .then(knownVocabularies => Global.fetchJSONPromise(\"http://prefix.cc/context\")\n            .then(responsePrefixCC => {\n                for (let prefix of Object.keys(responsePrefixCC['@context'])) {\n                    knownVocabularies.add(responsePrefixCC['@context'][prefix])\n                };\n                return Promise.resolve(knownVocabularies);\n            }))\n        .then(knownVocabularies => Global.fetchJSONPromise(\"https://www.ebi.ac.uk/ols/api/ontologies?page=0&size=1000\")\n            .then(responseOLS => {\n                responseOLS[\"_embedded\"].ontologies.forEach(ontologyItem => {\n                    if (ontologyItem.config.baseUris.length > 0) {\n                        let ontology = ontologyItem.config.baseUris[0]\n                        knownVocabularies.add(ontology);\n                    }\n                });\n                return Promise.resolve(knownVocabularies);\n            }))\n}\n\nfunction generateGraphValueFilterClause(graphList: string[]) {\n    let result = \"FILTER( \";\n    graphList.forEach((item, i) => {\n        if (i > 0) {\n            result += ` || REGEX( str(?g) , '${item}' )`;\n        } else {\n            result += `REGEX( str(?g) , '${item}' )`;\n        }\n    });\n    result += \" )\";\n    return result;\n}\n\nexport function endpointMapfill(runset: RunSetObject) {\n    Logger.info(\"endpointMapfill\", runset.id, \" START\")\n    let endpointGeolocData = [];\n    let endpointSet: Set<string> = new Set();\n    let endpointTimezoneSPARQL: Map<string, string> = new Map();\n    let endpointLabelMap: Map<string, string> = new Map();\n    let endpointIpMapArray: EndpointIpGeolocObject[] = [];\n\n    // Marked map with the geoloc of each endpoint\n    return endpointIpMap.then(endpointIpMap => {\n        endpointIpMapArray = endpointIpMap as EndpointIpGeolocObject[];\n        return Promise.resolve();\n    })\n        .then(() => {\n            let endpointListForRunsetQuery = `SELECT DISTINCT ?endpoint {\n            GRAPH ?g {\n                ?base <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpoint .\n                ?metadata <http://ns.inria.fr/kg/index#curated> ?base .\n            }\n            ${generateGraphValueFilterClause(runset.graphs)}\n        }`;\n            return Sparql.paginatedSparqlQueryToIndeGxPromise(endpointListForRunsetQuery).then(jsonResponse => {\n                (jsonResponse as JSONValue[]).forEach((itemResponse, i) => {\n                    endpointSet.add(itemResponse[\"endpoint\"].value);\n                });\n                return Promise.resolve();\n            })\n        })\n        .then(() => {\n            let timezoneSPARQLquery = `SELECT DISTINCT ?timezone ?endpoint { \n            GRAPH ?g { \n                ?base <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpoint . \n                ?metadata <http://ns.inria.fr/kg/index#curated> ?base . \n                ?base <https://schema.org/broadcastTimezone> ?timezone .\n            } \n            ${generateGraphValueFilterClause(runset.graphs)}\n        }`;\n            return Sparql.paginatedSparqlQueryToIndeGxPromise(timezoneSPARQLquery)\n                .then(jsonResponse => {\n                    if (jsonResponse != undefined) {\n                        (jsonResponse as JSONValue[]).forEach((itemResponse, i) => {\n                            endpointTimezoneSPARQL.set(itemResponse[\"endpoint\"].value, itemResponse[\"timezone\"].value);\n                        });\n                    }\n                    return Promise.resolve();\n                })\n        })\n        .then(() => {\n            let labelQuery = `SELECT DISTINCT ?label ?endpoint { \n                GRAPH ?g { \n                    ?dataset <http://rdfs.org/ns/void#sparqlEndpoint> ?endpoint . \n                    { ?dataset <http://www.w3.org/2000/01/rdf-schema#label> ?label } \n                    UNION { ?dataset <http://www.w3.org/2004/02/skos/core#prefLabel> ?label } \n                    UNION { ?dataset <http://purl.org/dc/terms/title> ?label } \n                    UNION { ?dataset <http://xmlns.com/foaf/0.1/name> ?label } \n                    UNION { ?dataset <http://schema.org/name> ?label } . \n                }  \n                ${generateGraphValueFilterClause(runset.graphs)}\n            }`;\n            return Sparql.sparqlQueryToIndeGxPromise(labelQuery)\n                .then(responseLabels => {\n                    responseLabels = responseLabels as SPARQLJSONResult;\n                    if (responseLabels != undefined) {\n                        responseLabels.results.bindings.forEach((itemResponse, i) => {\n                            endpointLabelMap.set(itemResponse[\"endpoint\"].value, itemResponse[\"label\"].value);\n                        });\n                    }\n                })\n        })\n        .then(() => {\n            let endpointItemMap = new Map<string, any>();\n            return Promise.allSettled((endpointIpMapArray as EndpointIpGeolocObject[]).map((item) => {\n                if (item !== undefined) {\n                    // Add the markers for each endpoints.\n                    let endpoint = item.key;\n                    let endpointItem: EndpointItem;\n\n                    if (endpointSet.has(endpoint)) {\n                        return timezoneMap.then(timeZoneMapArray => {\n                            let ipTimezoneArrayFiltered = (timeZoneMapArray as TimezoneMapObject[]).filter(itemtza => itemtza.key == item.value.geoloc.timezone);\n                            let ipTimezone;\n                            if (ipTimezoneArrayFiltered.length > 0) {\n                                ipTimezone = ipTimezoneArrayFiltered[0].value.utc_offset.padStart(6, '-').padStart(6, '+');\n                            }\n                            let sparqlTimezone;\n                            if (endpointTimezoneSPARQL.get(endpoint) != undefined) {\n                                sparqlTimezone = endpointTimezoneSPARQL.get(endpoint).padStart(6, '-').padStart(6, '+');\n                            }\n\n                            endpointItem = { endpoint: endpoint, lat: item.value.geoloc.lat, lon: item.value.geoloc.lon, country: \"\", region: \"\", city: \"\", org: \"\", timezone: ipTimezone, sparqlTimezone: sparqlTimezone, popupHTML: \"\" };\n                            if (item.value.geoloc.country != undefined) {\n                                endpointItem.country = item.value.geoloc.country;\n                            }\n                            if (item.value.geoloc.regionName != undefined) {\n                                endpointItem.region = item.value.geoloc.regionName;\n                            }\n                            if (item.value.geoloc.city != undefined) {\n                                endpointItem.city = item.value.geoloc.city;\n                            }\n                            if (item.value.geoloc.org != undefined) {\n                                endpointItem.org = item.value.geoloc.org;\n                            }\n                            endpointItemMap.set(endpoint, endpointItem);\n                            return Promise.resolve()\n                        })\n                    } else {\n                        return Promise.reject();\n                    }\n                } else {\n                    return Promise.reject();\n                }\n            })\n            ).then(() => {\n                return Promise.resolve(endpointItemMap);\n            });\n        })\n        .then(endpointItemMap => {\n            endpointItemMap.forEach((endpointItem, endpoint) => {\n                let popupString = `<table> <thead> <tr> <th colspan='2'> <a href='${endpointItem.endpoint}' >${endpointItem.endpoint}</a> </th> </tr> </thead></body>`;\n                if (endpointItem.country != undefined) {\n                    popupString += `<tr><td>Country: </td><td>${endpointItem.country}</td></tr>`;\n                }\n                if (endpointItem.region != undefined) {\n                    popupString += `<tr><td>Region: </td><td>${endpointItem.region}</td></tr>`;\n                }\n                if (endpointItem.city != undefined) {\n                    popupString += `<tr><td>City: </td><td>${endpointItem.city}</td></tr>`;\n                }\n                if (endpointItem.org != undefined) {\n                    popupString += `<tr><td>Organization: </td><td>${endpointItem.org}</td></tr>`;\n                }\n                if (endpointItem.timezone != undefined) {\n                    popupString += `<tr><td>Timezone of endpoint URL: </td><td>${endpointItem.timezone}</td></tr>`;\n                    if (endpointItem.sparqlTimezone != undefined) {\n                        let badTimezone = endpointItem.timezone.localeCompare(endpointItem.sparqlTimezone) != 0;\n                        if (badTimezone) {\n                            popupString += `<tr><td>Timezone declared by endpoint: </td><td>${endpointItem.sparqlTimezone}</td></tr>`;\n                        }\n                    }\n                }\n                if (endpointLabelMap.get(endpoint) != undefined) {\n                    let endpointLabel = endpointLabelMap.get(endpoint);\n                    popupString += `<tr><td colspan='2'>${endpointLabel}</td></tr>`;\n                }\n                popupString += \"</tbody></table>\"\n                endpointItem.popupHTML = popupString;\n            })\n\n            endpointItemMap.forEach((endpointItem, endpoint) => {\n                endpointGeolocData.push(endpointItem);\n            });\n            return Promise.resolve(endpointGeolocData);\n        })\n        .then(endpointGeolocData => {\n            try {\n                let content = JSON.stringify(endpointGeolocData);\n                Logger.info(\"endpointMapfill for\", runset.id, \"END\")\n                return Global.writeFile(Global.getCachedFilenameForRunset(runset.id, geolocFilename), content)\n            } catch (err) {\n                Logger.error(err)\n            }\n        })\n        .catch(error => {\n            Logger.error(error)\n        })\n}\n\nexport function SPARQLCoverageFill(runset: RunSetObject) {\n    Logger.info(\"SPARQLCoverageFill\", runset.id, \" START\")\n    // Create an histogram of the SPARQLES rules passed by endpoint.\n    let sparqlesFeatureQuery = `SELECT DISTINCT ?endpoint ?sparqlNorm (COUNT(DISTINCT ?activity) AS ?count) { \n            GRAPH ?g { \n                { ?curated <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpoint . }\n                UNION { ?curated <http://rdfs.org/ns/void#sparqlEndpoint> ?endpoint . }\n                UNION { ?curated <http://www.w3.org/ns/dcat#endpointURL> ?endpoint . }\n                ?metadata <http://ns.inria.fr/kg/index#curated> ?curated, ?dataset .\n                #OPTIONAL { \n                    { ?dataset <http://www.w3.org/ns/prov#wasGeneratedBy> ?activity . }\n                    UNION { ?metadata <http://www.w3.org/ns/prov#wasGeneratedBy> ?activity .}\n                    FILTER(CONTAINS(str(?activity), ?sparqlNorm)) \n                    VALUES ?sparqlNorm { \"SPARQL10\" \"SPARQL11\" } \n                #} \n            } \n            ${generateGraphValueFilterClause(runset.graphs)}\n        } \n        GROUP BY ?endpoint ?sparqlNorm `;\n    let jsonBaseFeatureSparqles = [];\n    let sparqlFeaturesDataArray = [];\n    return Sparql.paginatedSparqlQueryToIndeGxPromise(sparqlesFeatureQuery)\n        .then(json => {\n            let endpointSet = new Set();\n            let sparql10Map = new Map();\n            let sparql11Map = new Map();\n            (json as JSONValue[]).forEach((bindingItem, i) => {\n                let endpointUrl = bindingItem[\"endpoint\"].value;\n                endpointSet.add(endpointUrl);\n                let feature = undefined;\n                if (bindingItem[\"sparqlNorm\"] != undefined) {\n                    feature = bindingItem[\"sparqlNorm\"].value;\n                }\n                let count = bindingItem[\"count\"].value;\n                if (feature == undefined || feature.localeCompare(\"SPARQL10\") == 0) {\n                    sparql10Map.set(endpointUrl, Number(count));\n                }\n                if (feature == undefined || feature.localeCompare(\"SPARQL11\") == 0) {\n                    sparql11Map.set(endpointUrl, Number(count));\n                }\n            });\n\n            endpointSet.forEach((item) => {\n                let sparql10 = sparql10Map.get(item);\n                let sparql11 = sparql11Map.get(item);\n                if (sparql10 == undefined) {\n                    sparql10 = 0;\n                }\n                if (sparql11 == undefined) {\n                    sparql11 = 0;\n                }\n                let sparqlJSONObject = { 'endpoint': item, 'sparql10': sparql10, 'sparql11': sparql11, 'sparqlTotal': (sparql10 + sparql11) };\n                jsonBaseFeatureSparqles.push(sparqlJSONObject);\n            });\n\n\n        })\n        .then(() => {\n            const sparqlFeatureQuery = `SELECT DISTINCT ?endpoint ?activity { \n                GRAPH ?g { \n                    { ?curated <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpoint . }\n                    UNION { ?curated <http://rdfs.org/ns/void#sparqlEndpoint> ?endpoint . }\n                    UNION { ?curated <http://www.w3.org/ns/dcat#endpointURL> ?endpoint . }\n                    ?metadata <http://ns.inria.fr/kg/index#curated> ?curated, ?dataset .\n                    #OPTIONAL { \n                        { ?dataset <http://www.w3.org/ns/prov#wasGeneratedBy> ?activity . }\n                        UNION { ?metadata <http://www.w3.org/ns/prov#wasGeneratedBy> ?activity .}\n                        FILTER(CONTAINS(str(?activity), ?sparqlNorm)) \n                        VALUES ?sparqlNorm { \"SPARQL10\" \"SPARQL11\" } \n                    #} \n                } \n                ${generateGraphValueFilterClause(runset.graphs)}\n            } GROUP BY ?endpoint ?activity `;\n            let endpointFeatureMap = new Map();\n            let featuresShortName = new Map();\n            return Sparql.paginatedSparqlQueryToIndeGxPromise(sparqlFeatureQuery)\n                .then(json => {\n                    endpointFeatureMap = new Map();\n                    let featuresSet = new Set();\n                    (json as JSONValue[]).forEach(bindingItem => {\n                        const endpointUrl = bindingItem[\"endpoint\"].value;\n                        if (!endpointFeatureMap.has(endpointUrl)) {\n                            endpointFeatureMap.set(endpointUrl, new Set());\n                        }\n                        if (bindingItem[\"activity\"] != undefined) {\n                            const activity = bindingItem[\"activity\"].value;\n                            if (!endpointFeatureMap.has(endpointUrl)) {\n                                endpointFeatureMap.set(endpointUrl, new Set());\n                            }\n                            featuresSet.add(activity);\n                            if (featuresShortName.get(activity) == undefined) {\n                                featuresShortName.set(activity, activity.replace(\"https://raw.githubusercontent.com/Wimmics/dekalog/master/rules/sparqles/SPARQL10/SPARQLES_\", \"sparql10:\").replace(\"https://raw.githubusercontent.com/Wimmics/dekalog/master/rules/sparqles/SPARQL11/SPARQLES_\", \"sparql11:\").replace(\".ttl#activity\", \"\"))\n                            }\n                            endpointFeatureMap.get(endpointUrl).add(featuresShortName.get(activity));\n                        }\n                    });\n                    endpointFeatureMap.forEach((featureSet, endpointUrl, map) => {\n                        let sortedFeatureArray = [...featureSet].sort((a, b) => a.localeCompare(b));\n                        sparqlFeaturesDataArray.push({ endpoint: endpointUrl, features: sortedFeatureArray });\n                    });\n\n                    sparqlFeaturesDataArray.sort((a, b) => {\n                        return a.endpoint.localeCompare(b.endpoint);\n                    });\n                })\n        })\n        .finally(() => {\n            if (jsonBaseFeatureSparqles.length > 0) {\n                try {\n                    let content = JSON.stringify(jsonBaseFeatureSparqles);\n                    fs.writeFileSync(Global.getCachedFilenameForRunset(runset.id, sparqlCoverageFilename), content)\n                } catch (err) {\n                    Logger.error(err)\n                }\n            }\n            if (sparqlFeaturesDataArray.length > 0) {\n                try {\n                    let content = JSON.stringify(sparqlFeaturesDataArray);\n                    fs.writeFileSync(Global.getCachedFilenameForRunset(runset.id, sparqlFeaturesFilename), content)\n                } catch (err) {\n                    Logger.error(err)\n                }\n            }\n            Logger.info(\"SPARQLCoverageFill\", runset.id, \" END\")\n        })\n        .catch(error => {\n            Logger.error(error)\n        })\n}\n\nlet endpointVocabMap: Map<string, string[]> = new Map();\nlet vocabKeywords: Map<string, string[]> = new Map();\nlet endpointKeywords: Map<string, string[]> = new Map();\nexport function allVocabFill(): Promise<void> {\n    Logger.info(\"allVocabFill START\")\n\n    let sparqlQuery = `SELECT DISTINCT ?endpointUrl ?vocabulary {\n        GRAPH ?g {\n            { ?curated <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . }\n            UNION { ?curated <http://rdfs.org/ns/void#sparqlEndpoint> ?endpointUrl . }\n            UNION { ?curated <http://www.w3.org/ns/dcat#endpointURL> ?endpointUrl . }\n            ?metadata <http://ns.inria.fr/kg/index#curated> ?curated, ?dataset .\n            ?dataset <http://rdfs.org/ns/void#vocabulary> ?vocabulary .\n        }\n    }`;\n\n    return Sparql.paginatedSparqlQueryToIndeGxPromise(sparqlQuery).then(json => {\n        let vocabSet = new Set();\n        (json as JSONValue[]).forEach(bindingItem => {\n            const endpointUrl = bindingItem[\"endpointUrl\"].value;\n            const vocabulary = bindingItem[\"vocabulary\"].value;\n            if (!endpointVocabMap.has(endpointUrl)) {\n                endpointVocabMap.set(endpointUrl, []);\n            }\n            if (knownVocabularies.has(vocabulary)) {\n                endpointVocabMap.get(endpointUrl).push(vocabulary);\n                vocabSet.add(vocabulary);\n            }\n        });\n        return vocabSet;\n    }).then(vocabSet => {\n\n        let vocabArray = [...vocabSet];\n        let queryArray = vocabArray.map((item, i) => {\n            return Global.fetchJSONPromise(`https://lov.linkeddata.es/dataset/lov/api/v2/vocabulary/info?vocab=${item}`);\n        })\n\n        return Promise.allSettled(queryArray)\n            .then(jsonKeywordsArraySettled => {\n                let jsonKeywordsArray = Global.extractSettledPromiseValues(jsonKeywordsArraySettled);\n                jsonKeywordsArray.forEach(jsonKeywords => {\n                    Logger.log(jsonKeywords)\n                    if (jsonKeywords !== undefined) {\n                        let vocab = jsonKeywords.uri;\n                        let keywordList = jsonKeywords.tags;\n\n                        if (keywordList !== undefined) {\n                            keywordList.forEach(keyword => {\n                                if (!vocabKeywords.has(vocab)) {\n                                    vocabKeywords.set(vocab, []);\n                                }\n                                vocabKeywords.get(vocab).push(keyword);\n                            })\n                        }\n                    }\n                })\n                return Promise.resolve();\n            }).then(() => {\n                endpointVocabMap.forEach((vocabArray, endpointUrl, map) => {\n                    let keywordSet: Set<string> = new Set();\n                    vocabArray.forEach(vocab => {\n                        if (vocabKeywords.has(vocab)) {\n                            vocabKeywords.get(vocab).forEach(keyword => {\n                                keywordSet.add(keyword);\n                            })\n                        }\n                    })\n                    endpointKeywords.set(endpointUrl, [...keywordSet]);\n                })\n                return Promise.resolve();\n            })\n    }).catch(error => {\n        Logger.error(error)\n    })\n}\n\nexport function vocabFill(runset: RunSetObject): Promise<void> {\n    Logger.info(\"vocabFill\", runset.id, \" START\")\n    let runsetsEndpointQuery = `SELECT DISTINCT ?endpointUrl { \n        GRAPH ?g { \n            { ?curated <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . }\n            UNION { ?curated <http://rdfs.org/ns/void#sparqlEndpoint> ?endpointUrl . } \n            UNION { ?curated <http://www.w3.org/ns/dcat#endpointURL> ?endpointUrl . }\n            ?metadata <http://ns.inria.fr/kg/index#curated> ?curated .\n        } \n        ${generateGraphValueFilterClause(runset.graphs)}\n    } \n    GROUP BY ?endpointUrl ?vocabulary `;\n\n    return Sparql.paginatedSparqlQueryToIndeGxPromise(runsetsEndpointQuery).then(json => {\n        if (json !== undefined) {\n            let endpointSet: Set<string> = new Set();\n            (json as JSONValue[]).forEach(bindingItem => {\n                const endpointUrl = bindingItem[\"endpointUrl\"].value;\n                endpointSet.add(endpointUrl);\n            });\n            return endpointSet;\n        } else {\n            return Promise.resolve(new Set<string>());\n        }\n    }).then(endpointSet => {\n        let runsetEndpointVocabulary: Map<string, string[]> = new Map();\n        endpointSet.forEach(endpointUrl => {\n            runsetEndpointVocabulary.set(endpointUrl, endpointVocabMap.get(endpointUrl));\n        })\n\n        let runsetEndpointKeywords: Map<string, string[]> = new Map();\n        endpointSet.forEach(endpointUrl => {\n            runsetEndpointKeywords.set(endpointUrl, endpointKeywords.get(endpointUrl));\n        });\n\n        try {\n            let endpointVocabData: VocabEndpointDataObject[] = [];\n            runsetEndpointVocabulary.forEach((vocabArray, endpointUrl, map) => {\n                endpointVocabData.push({ endpoint: endpointUrl, vocabularies: vocabArray });\n            })\n            let content = JSON.stringify(endpointVocabData);\n            return Global.writeFile(Global.getCachedFilenameForRunset(runset.id, vocabEndpointFilename), content)\n                .then(() => {\n                    let endpointKeywordsData: KeywordsEndpointDataObject[] = [];\n                    runsetEndpointKeywords.forEach((keywordArray, endpointUrl, map) => {\n                        endpointKeywordsData.push({ endpoint: endpointUrl, keywords: keywordArray });\n                    })\n                    let content = JSON.stringify(endpointKeywordsData);\n                    return Global.writeFile(Global.getCachedFilenameForRunset(runset.id, endpointKeywordsFilename), content)\n                })\n                .then(() => {\n                    Logger.info(\"vocabFill\", runset.id, \" END\")\n                    return Promise.resolve();\n                })\n        } catch (err) {\n            Logger.error(err)\n        }\n\n    })\n\n}\n\n// export function vocabFillOld(runset: RunSetObject): Promise<void> {\n//     Logger.info(\"vocabFill\", runset.id, \" START\")\n//     // Create an force graph with the graph linked by co-ocurrence of vocabularies\n//     let sparqlesVocabulariesQuery = `SELECT DISTINCT ?endpointUrl ?vocabulary { \n//         GRAPH ?g { \n//             { ?curated <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . }\n//             UNION { ?curated <http://rdfs.org/ns/void#sparqlEndpoint> ?endpointUrl . } \n//             UNION { ?curated <http://www.w3.org/ns/dcat#endpointURL> ?endpointUrl . }\n//             ?metadata <http://ns.inria.fr/kg/index#curated> ?curated, dataset . \n//             ?dataset <http://rdfs.org/ns/void#vocabulary> ?vocabulary \n//         } \n//         ${generateGraphValueFilterClause(runset.graphs)}\n//     } \n//     GROUP BY ?endpointUrl ?vocabulary `;\n//     let rawGatherVocab = new Map();\n//     let gatherVocabData = [];\n//     let rawVocabSet = new Set();\n//     let vocabSet = new Set();\n//     let keywordSet = new Set();\n//     let vocabKeywordData = [];\n\n//     return Sparql.paginatedSparqlQueryToIndeGxPromise(sparqlesVocabulariesQuery)\n//         .then(json => {\n\n//             let endpointSet = new Set();\n//             (json as JSONValue[]).forEach((bindingItem, i) => {\n//                 let vocabulariUri = bindingItem[\"vocabulary\"].value;\n//                 let endpointUri = bindingItem[\"endpointUrl\"].value;\n//                 endpointSet.add(endpointUri);\n//                 rawVocabSet.add(vocabulariUri);\n//                 if (!rawGatherVocab.has(endpointUri)) {\n//                     rawGatherVocab.set(endpointUri, new Set());\n//                 }\n//                 rawGatherVocab.get(endpointUri).add(vocabulariUri);\n//             });\n//             return Promise.resolve();\n//         })\n//         .then(() => {\n//             try {\n//                 let content = JSON.stringify([...knownVocabularies]);\n//                 return Global.writeFile(Global.getCachedFilenameForRunset(runset.id, knownVocabsFilename), content).then(() => {\n//                     return Promise.resolve(knownVocabularies);\n//                 });\n//             } catch (err) {\n//                 Logger.error(err)\n//                 return Promise.reject(err);\n//             }\n//         })\n//         .then(() => {\n//             // Filtering according to ontology repositories\n//             rawVocabSet.forEach(vocabulariUri => {\n//                 if (knownVocabularies.has(vocabulariUri)) {\n//                     vocabSet.add(vocabulariUri);\n//                 }\n//             });\n//             rawGatherVocab.forEach((vocabulariUriSet, endpointUri, map) => {\n//                 gatherVocabData.push({ endpoint: endpointUri, vocabularies: [...vocabulariUriSet] })\n//             });\n\n//             let vocabArray = [...vocabSet];\n//             let queryArray = vocabArray.map((item, i) => {\n//                 return Global.fetchJSONPromise(`https://lov.linkeddata.es/dataset/lov/api/v2/vocabulary/info?vocab=${item}`);\n//             })\n\n//             return Promise.allSettled(queryArray)\n//                 .then(jsonKeywordsArraySettled => {\n//                     let jsonKeywordsArray = Global.extractSettledPromiseValues(jsonKeywordsArraySettled);\n//                     let vocabKeywordMap = new Map();\n//                     jsonKeywordsArray.forEach(jsonKeywords => {\n//                         if (jsonKeywords !== undefined) {\n//                             let vocab = jsonKeywords.uri;\n//                             let keywordList = jsonKeywords.tags;\n\n//                             if(keywordList !== undefined) {\n//                                 if (vocabKeywordMap.get(vocab) == undefined) {\n//                                     vocabKeywordMap.set(vocab, []);\n//                                 }\n//                                 vocabKeywordMap.get(vocab).push(...keywordList);\n//                                 keywordList.forEach(keyword => {\n//                                     keywordSet.add(keyword);\n//                                 })\n\n//                             }\n//                         }\n//                     })\n//                     vocabKeywordMap.forEach((keywordList, vocab) => {\n//                         vocabKeywordData.push({ vocabulary: vocab, keywords: keywordList })\n//                     })\n//                     return Promise.resolve();\n//                 })\n//         })\n//         .finally(() => {\n//             if (gatherVocabData.length > 0) {\n//                 try {\n//                     let content = JSON.stringify(gatherVocabData);\n//                     return Global.writeFile(Global.getCachedFilenameForRunset(runset.id, vocabEndpointFilename), content)\n//                 } catch (err) {\n//                     Logger.error(err)\n//                 }\n//             }\n//         })\n//         .finally(() => {\n//             if (vocabKeywordData.length > 0) {\n//                 try {\n//                     let content = JSON.stringify(vocabKeywordData);\n//                     return Global.writeFile(Global.getCachedFilenameForRunset(runset.id, vocabKeywordsFilename), content).then(() => {\n//                         Logger.info(\"vocabFill\", runset.id, \" END\");\n//                         return Promise.resolve();\n//                     });\n//                 } catch (err) {\n//                     Logger.error(err)\n//                 }\n//             }\n//         })\n//         .catch(error => {\n//             Logger.error(error);\n//             return Promise.reject(error);\n//         })\n// }\n\nexport function tripleDataFill(runset: RunSetObject) {\n    Logger.info(\"tripleDataFill\", runset.id, \" START\")\n    // Scatter plot of the number of triples through time\n    let triplesSPARQLquery = `SELECT DISTINCT ?g ?date ?endpointUrl (MAX(?rawO) AS ?o) {\n        GRAPH ?g {\n            { ?curated <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . }\n            UNION { ?curated <http://rdfs.org/ns/void#sparqlEndpoint> ?endpointUrl . }\n            UNION { ?curated <http://www.w3.org/ns/dcat#endpointURL> ?endpointUrl . }\n            ?metadata <http://ns.inria.fr/kg/index#curated> ?curated .\n            ?curated <http://rdfs.org/ns/void#triples> ?rawO .\n        }\n        ${generateGraphValueFilterClause(runset.graphs)}\n    } GROUP BY ?g ?date ?endpointUrl`;\n\n    // {?metadata <http://purl.org/dc/terms/modified> ?date .}\n    // UNION { ?curated <http://purl.org/dc/terms/modified> ?date . }\n    type EndpointTripleIndexItem = { date: Dayjs, triples: number };\n    return Sparql.paginatedSparqlQueryToIndeGxPromise(triplesSPARQLquery)\n        .then(json => {\n            let endpointTriplesDataIndex: Map<string, Map<string, EndpointTripleIndexItem>> = new Map();\n            let endpointTriplesData: TripleCountDataObject[] = [];\n            (json as JSONValue[]).forEach((itemResult, i) => {\n                let graph: string = itemResult[\"g\"].value.replace('http://ns.inria.fr/indegx#', '');\n                let date: Dayjs; //= Global.parseDate(itemResult[\"date\"].value);\n                let rawDateUnderscoreIndex = graph.lastIndexOf(\"_\"); // Cheating on the date of the indexation\n                if (rawDateUnderscoreIndex != -1) {\n                    let rawDate = graph.substring(rawDateUnderscoreIndex, graph.length);\n                    date = Global.parseDate(rawDate, \"YYYYMMDD\");\n                }\n                let endpointUrl = itemResult[\"endpointUrl\"].value;\n                let triples = Number.parseInt(itemResult[\"o\"].value);\n\n                if (endpointTriplesDataIndex.get(endpointUrl) == undefined) {\n                    endpointTriplesDataIndex.set(endpointUrl, new Map());\n                }\n                if (endpointTriplesDataIndex.get(endpointUrl).get(graph) == undefined) {\n                    endpointTriplesDataIndex.get(endpointUrl).set(graph, { date: date, triples: triples });\n                } else {\n                    let previousDate = endpointTriplesDataIndex.get(endpointUrl).get(graph).date;\n                    if (date.isBefore(previousDate) && date.year() != previousDate.year() && date.month() != previousDate.month() && date.date() != previousDate.date()) {\n                        endpointTriplesDataIndex.get(endpointUrl).set(graph, { date: date, triples: triples });\n                    }\n                }\n            });\n            endpointTriplesDataIndex.forEach((graphTripleMap, endpointUrl) => {\n                graphTripleMap.forEach((tripleData, graph) => {\n                    endpointTriplesData.push({ endpoint: endpointUrl, graph: graph, date: tripleData.date, triples: tripleData.triples })\n                })\n            });\n            return Promise.resolve(endpointTriplesData);\n        })\n        .then(endpointTriplesData => {\n            try {\n                let content = JSON.stringify(endpointTriplesData);\n                return Global.writeFile(Global.getCachedFilenameForRunset(runset.id, tripleCountFilename), content).then(() => {\n                    Logger.info(\"tripleDataFill\", runset.id, \" END\");\n                    return Promise.resolve();\n                })\n            } catch (err) {\n                Logger.error(err)\n                return Promise.reject(err);\n            }\n        })\n        .catch(error => {\n            Logger.error(error)\n            return Promise.reject(error);\n        });\n}\n\nexport function classDataFill(runset: RunSetObject) {\n    Logger.info(\"classDataFill\", runset.id, \" START\")\n    // Scatter plot of the number of classes through time\n    let classesSPARQLquery = `SELECT DISTINCT ?g ?endpointUrl ?date (MAX(?rawO) AS ?o) { \n        GRAPH ?g {\n            { ?curated <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . }\n            UNION { ?curated <http://rdfs.org/ns/void#sparqlEndpoint> ?endpointUrl . }\n            UNION { ?curated <http://www.w3.org/ns/dcat#endpointURL> ?endpointUrl . }\n            ?metadata <http://ns.inria.fr/kg/index#curated> ?curated .\n            ?curated <http://rdfs.org/ns/void#classes> ?rawO .\n        }\n        ${generateGraphValueFilterClause(runset.graphs)}\n    } GROUP BY ?g ?endpointUrl ?date`;\n    // {?metadata <http://purl.org/dc/terms/modified> ?date .}\n    // UNION { ?curated <http://purl.org/dc/terms/modified> ?date . }\n    type EndpointClassesIndexItem = { date: Dayjs, classes: number };\n    let endpointClassesDataIndex: Map<string, Map<string, EndpointClassesIndexItem>> = new Map();\n    return Sparql.paginatedSparqlQueryToIndeGxPromise(classesSPARQLquery)\n        .then(json => {\n            let endpointClassCountData: ClassCountDataObject[] = [];\n            (json as JSONValue[]).forEach((itemResult, i) => {\n                let graph = itemResult[\"g\"].value.replace('http://ns.inria.fr/indegx#', '');\n                let date: Dayjs;//= Global.parseDate(itemResult[\"date\"].value);\n                let rawDateUnderscoreIndex = graph.lastIndexOf(\"_\"); // Cheating on the date of the indexation\n                if (rawDateUnderscoreIndex != -1) {\n                    let rawDate = graph.substring(rawDateUnderscoreIndex, graph.length);\n                    date = Global.parseDate(rawDate, \"YYYYMMDD\");\n                }\n                let endpointUrl = itemResult[\"endpointUrl\"].value;\n                let classes = Number.parseInt(itemResult[\"o\"].value);\n                if (endpointClassesDataIndex.get(endpointUrl) == undefined) {\n                    endpointClassesDataIndex.set(endpointUrl, new Map());\n                }\n                if (endpointClassesDataIndex.get(endpointUrl).get(graph) == undefined) {\n                    endpointClassesDataIndex.get(endpointUrl).set(graph, { date: date, classes: classes });\n                } else {\n                    let previousDate = endpointClassesDataIndex.get(endpointUrl).get(graph).date;\n                    if (date.isBefore(previousDate) && date.year() != previousDate.year() && date.month() != previousDate.month() && date.date() != previousDate.date()) {\n                        endpointClassesDataIndex.get(endpointUrl).set(graph, { date: date, classes: classes });\n                    }\n                }\n            });\n            endpointClassesDataIndex.forEach((graphClassesMap, endpointUrl) => {\n                graphClassesMap.forEach((classesData, graph) => {\n                    endpointClassCountData.push({ endpoint: endpointUrl, graph: graph, date: classesData.date, classes: classesData.classes })\n                })\n            });\n            return Promise.resolve(endpointClassCountData);\n        })\n        .then(endpointClassCountData => {\n            try {\n                let content = JSON.stringify(endpointClassCountData);\n                return Global.writeFile(Global.getCachedFilenameForRunset(runset.id, classCountFilename), content).then(() => {\n                    Logger.info(\"classDataFill\", runset.id, \" END\")\n                    return Promise.resolve();\n                })\n            } catch (err) {\n                Logger.error(err);\n                return Promise.reject(err);\n            }\n        })\n        .catch(error => {\n            Logger.error(error)\n            return Promise.reject(error);\n        });\n}\n\nexport function propertyDataFill(runset: RunSetObject) {\n    Logger.info(\"propertyDataFill\", runset.id, \" START\")\n    // scatter plot of the number of properties through time\n    let propertiesSPARQLquery = `SELECT DISTINCT ?g ?date ?endpointUrl (MAX(?rawO) AS ?o) {\n        GRAPH ?g {\n            { ?curated <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . }\n            UNION { ?curated <http://rdfs.org/ns/void#sparqlEndpoint> ?endpointUrl . }\n            UNION { ?curated <http://www.w3.org/ns/dcat#endpointURL> ?endpointUrl . }\n            ?metadata <http://ns.inria.fr/kg/index#curated> ?curated .\n            ?curated <http://rdfs.org/ns/void#properties> ?rawO .\n        }\n        ${generateGraphValueFilterClause(runset.graphs)}\n    } GROUP BY ?endpointUrl ?g ?date`;\n    // {?metadata <http://purl.org/dc/terms/modified> ?date .}\n    // UNION { ?curated <http://purl.org/dc/terms/modified> ?date . }\n    type EndpointPropertiesIndexItem = { date: Dayjs, properties: number };\n    let endpointPropertiesDataIndex = new Map();\n    return Sparql.paginatedSparqlQueryToIndeGxPromise(propertiesSPARQLquery)\n        .then(json => {\n            let endpointPropertyCountData = [];\n            (json as JSONValue[]).forEach((itemResult, i) => {\n                let graph = itemResult[\"g\"].value.replace('http://ns.inria.fr/indegx#', '');\n                let endpointUrl = itemResult[\"endpointUrl\"].value;\n                let properties = Number.parseInt(itemResult[\"o\"].value);\n                let date: Dayjs; // = Global.parseDate(itemResult[\"date\"].value);\n                let rawDateUnderscoreIndex = graph.lastIndexOf(\"_\"); // Cheating on the date of the indexation\n                if (rawDateUnderscoreIndex != -1) {\n                    let rawDate = graph.substring(rawDateUnderscoreIndex, graph.length);\n                    date = Global.parseDate(rawDate, \"YYYYMMDD\");\n                }\n\n                if (endpointPropertiesDataIndex.get(endpointUrl) == undefined) {\n                    endpointPropertiesDataIndex.set(endpointUrl, new Map());\n                }\n                if (endpointPropertiesDataIndex.get(endpointUrl).get(graph) == undefined) {\n                    endpointPropertiesDataIndex.get(endpointUrl).set(graph, { date: date, properties: properties });\n                } else {\n                    let previousDate = endpointPropertiesDataIndex.get(endpointUrl).get(graph).date;\n                    if (date.isAfter(previousDate)) {\n                        endpointPropertiesDataIndex.get(endpointUrl).set(graph, { date: date, properties: properties });\n                    }\n                }\n            });\n            endpointPropertiesDataIndex.forEach((graphPropertiesMap, endpointUrl) => {\n                graphPropertiesMap.forEach((propertiesData, graph) => {\n                    endpointPropertyCountData.push({ endpoint: endpointUrl, graph: graph, date: propertiesData.date, properties: propertiesData.properties })\n                })\n            });\n            return Promise.resolve(endpointPropertyCountData);\n        })\n        .then(endpointPropertyCountData => {\n            try {\n                let content = JSON.stringify(endpointPropertyCountData);\n                return Global.writeFile(Global.getCachedFilenameForRunset(runset.id, propertyCountFilename), content).then(() => {\n                    Logger.info(\"propertyDataFill\", runset.id, \" END\")\n                    return Promise.resolve();\n                })\n            } catch (err) {\n                Logger.error(err)\n                return Promise.reject(err);\n            }\n        })\n        .catch(error => {\n            Logger.error(error)\n            return Promise.reject(error);\n        });\n}\n\nexport function categoryTestCountFill(runset: RunSetObject) {\n    Logger.info(\"categoryTestCountFill\", runset.id, \" START\")\n    let testCategoryData = [];\n    // Number of tests passed by test categories\n    let testCategoryQuery = `SELECT DISTINCT ?g ?date ?category (count(DISTINCT ?test) AS ?count) ?endpointUrl { \n        GRAPH ?g { \n            ?metadata <http://ns.inria.fr/kg/index#curated> ?curated .\n            ?metadata <http://ns.inria.fr/kg/index#trace> ?trace . \n            { ?curated <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . } \n            UNION { ?curated <http://rdfs.org/ns/void#sparqlEndpoint> ?endpointUrl . } \n            UNION { ?curated <http://www.w3.org/ns/dcat#endpointURL> ?endpointUrl . }\n            ?trace <http://www.w3.org/ns/earl#test> ?test . \n            ?trace <http://www.w3.org/ns/earl#result> ?result .\n            ?result <http://www.w3.org/ns/earl#outcome> <http://www.w3.org/ns/earl#passed> .\n            FILTER(STRSTARTS(str(?test), ?category))\n            VALUES ?category { \n                'https://raw.githubusercontent.com/Wimmics/dekalog/master/rules/check/' \n                'https://raw.githubusercontent.com/Wimmics/dekalog/master/rules/extraction/asserted/' \n                'https://raw.githubusercontent.com/Wimmics/dekalog/master/rules/extraction/computed/' \n                'https://raw.githubusercontent.com/Wimmics/dekalog/master/rules/sportal/' \n                'https://raw.githubusercontent.com/Wimmics/dekalog/master/rules/sparqles/SPARQL10/'\n                'https://raw.githubusercontent.com/Wimmics/dekalog/master/rules/sparqles/SPARQL11/' \n            }\n        }  \n        ${generateGraphValueFilterClause(runset.graphs)}\n    } GROUP BY ?g ?date ?category ?endpointUrl`;\n    // {?metadata <http://purl.org/dc/terms/modified> ?date .}\n    // UNION { ?curated <http://purl.org/dc/terms/modified> ?date . }\n    return Sparql.paginatedSparqlQueryToIndeGxPromise(testCategoryQuery)\n        .then(json => {\n            (json as JSONValue[]).forEach((itemResult, i) => {\n                let category = itemResult[\"category\"].value;\n                let count = itemResult[\"count\"].value;\n                let endpoint = itemResult[\"endpointUrl\"].value;\n                let graph = itemResult[\"g\"].value.replace('http://ns.inria.fr/indegx#', '');\n                let date: Dayjs; // = Global.parseDate(itemResult[\"date\"].value);\n                let rawDateUnderscoreIndex = graph.lastIndexOf(\"_\"); // Cheating on the date of the indexation\n                if (rawDateUnderscoreIndex != -1) {\n                    let rawDate = graph.substring(rawDateUnderscoreIndex, graph.length);\n                    date = Global.parseDate(rawDate, \"YYYYMMDD\");\n                }\n                testCategoryData.push({ category: category, graph: graph, date: date, endpoint: endpoint, count: count });\n            });\n            return Promise.resolve();\n        })\n        .then(() => {\n            if (testCategoryData.length > 0) {\n                try {\n                    let content = JSON.stringify(testCategoryData);\n                    return Global.writeFile(Global.getCachedFilenameForRunset(runset.id, categoryTestCountFilename), content).then(() => {\n                        Logger.info(\"categoryTestCountFill\", runset.id, \" END\")\n                        return Promise.resolve();\n                    });\n                } catch (err) {\n                    Logger.error(err)\n                }\n            }\n        })\n        .catch(error => {\n            Logger.error(error)\n            return Promise.reject(error);\n        });\n}\n\nexport function totalCategoryTestCountFill(runset: RunSetObject) {\n    Logger.info(\"totalCategoryTestCountFill\", runset.id, \" START\")\n    // Number of tests passed by test categories\n    let testCategoryQuery = `SELECT DISTINCT ?category ?g ?date (count(DISTINCT ?test) AS ?count) ?endpointUrl { \n        GRAPH ?g { \n            ?metadata <http://ns.inria.fr/kg/index#curated> ?curated .\n            ?metadata <http://ns.inria.fr/kg/index#trace> ?trace .\n            { ?curated <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . }\n            UNION { ?curated <http://rdfs.org/ns/void#sparqlEndpoint> ?endpointUrl . }\n            UNION { ?curated <http://www.w3.org/ns/dcat#endpointURL> ?endpointUrl . }\n            ?trace <http://www.w3.org/ns/earl#test> ?test .\n            ?trace <http://www.w3.org/ns/earl#result> ?result .\n            ?result <http://www.w3.org/ns/earl#outcome> <http://www.w3.org/ns/earl#passed> .\n            FILTER(STRSTARTS(str(?test), str(?category))) \n            VALUES ?category {\n                <https://raw.githubusercontent.com/Wimmics/dekalog/master/rules/check/> \n                <https://raw.githubusercontent.com/Wimmics/dekalog/master/rules/extraction/asserted/> \n                <https://raw.githubusercontent.com/Wimmics/dekalog/master/rules/extraction/computed/> \n                <https://raw.githubusercontent.com/Wimmics/dekalog/master/rules/sportal/>\n                <https://raw.githubusercontent.com/Wimmics/dekalog/master/rules/sparqles/SPARQL10/> \n                <https://raw.githubusercontent.com/Wimmics/dekalog/master/rules/sparqles/SPARQL11/> \n            } \n        } \n        ${generateGraphValueFilterClause(runset.graphs)}\n    } \n    GROUP BY ?g ?date ?category ?endpointUrl \n    ORDER BY ?category `;\n    // ?metadata <http://purl.org/dc/terms/modified> ?date .\n    return Sparql.paginatedSparqlQueryToIndeGxPromise(testCategoryQuery).then(json => {\n        let totalTestCategoryData = [];\n        (json as JSONValue[]).forEach((itemResult, i) => {\n            let category = itemResult[\"category\"].value;\n            let count = itemResult[\"count\"].value;\n            let endpoint = itemResult[\"endpointUrl\"].value;\n            let graph = itemResult[\"g\"].value;\n            let date: Dayjs; // = Global.parseDate(itemResult[\"date\"].value);\n            let rawDateUnderscoreIndex = graph.lastIndexOf(\"_\"); // Cheating on the date of the indexation\n            if (rawDateUnderscoreIndex != -1) {\n                let rawDate = graph.substring(rawDateUnderscoreIndex, graph.length);\n                date = Global.parseDate(rawDate, \"YYYYMMDD\");\n            }\n\n            totalTestCategoryData.push({ category: category, endpoint: endpoint, graph: graph, date: date, count: count })\n            return Promise.resolve(totalTestCategoryData);\n        });\n    })\n        .then(totalTestCategoryData => {\n            try {\n                let content = JSON.stringify(totalTestCategoryData);\n                return Global.writeFile(Global.getCachedFilenameForRunset(runset.id, totalCategoryTestCountFilename), content).then(() => {\n                    Logger.info(\"totalCategoryTestCountFill\", runset.id, \" END\")\n                    return Promise.resolve();\n                })\n            } catch (err) {\n                Logger.error(err)\n                return Promise.reject(err);\n            }\n        })\n        .catch(error => {\n            Logger.error(error)\n            return Promise.reject();\n        });\n}\n\nexport function endpointTestsDataFill(runset: RunSetObject) {\n    Logger.info(\"endpointTestsDataFill\", runset.id, \" START\")\n\n    let appliedTestQuery = `SELECT DISTINCT ?endpointUrl ?g ?date ?rule { \n        GRAPH ?g { \n            ?metadata <http://ns.inria.fr/kg/index#curated> ?curated . \n            ?curated <http://www.w3.org/ns/prov#wasGeneratedBy> ?rule . \n            { ?curated <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . } \n            UNION { ?curated <http://rdfs.org/ns/void#sparqlEndpoint> ?endpointUrl . } \n            UNION { ?curated <http://www.w3.org/ns/dcat#endpointURL> ?endpointUrl . }\n        } \n        ${generateGraphValueFilterClause(runset.graphs)}\n    }`;\n    // {?metadata <http://purl.org/dc/terms/modified> ?date .}\n    // UNION { ?curated <http://purl.org/dc/terms/modified> ?date . }\n    type EndpointTestItem = { activity: string, date: Dayjs };\n    let endpointGraphTestsIndex: Map<string, Map<string, EndpointTestItem>> = new Map();\n    return Sparql.paginatedSparqlQueryToIndeGxPromise(appliedTestQuery)\n        .then(json => {\n            let endpointTestsData: EndpointTestObject[] = [];\n            (json as JSONValue[]).forEach((item, i) => {\n                let endpointUrl = item[\"endpointUrl\"].value;\n                let rule = item[\"rule\"].value;\n                let graph = item[\"g\"].value;\n                let date: Dayjs; // = Global.parseDate(item[\"date\"].value);\n                let rawDateUnderscoreIndex = graph.lastIndexOf(\"_\"); // Cheating on the date of the indexation\n                if (rawDateUnderscoreIndex != -1) {\n                    let rawDate = graph.substring(rawDateUnderscoreIndex, graph.length);\n                    date = Global.parseDate(rawDate, \"YYYYMMDD\");\n                }\n\n                if (!endpointGraphTestsIndex.has(endpointUrl)) {\n                    endpointGraphTestsIndex.set(endpointUrl, new Map());\n                }\n                let graphTestsIndex = endpointGraphTestsIndex.get(endpointUrl);\n                if (!graphTestsIndex.has(graph)) {\n                    graphTestsIndex.set(graph, { activity: rule, date: date });\n                } else {\n                    let previousDate = endpointGraphTestsIndex.get(endpointUrl).get(graph).date;\n                    if (date.isBefore(previousDate)) {\n                        endpointGraphTestsIndex.get(endpointUrl).set(graph, { activity: rule, date: date });\n                    }\n                }\n\n                endpointGraphTestsIndex.forEach((graphTestsIndex, endpointUrl) => {\n                    graphTestsIndex.forEach((item, graph) => {\n                        endpointTestsData.push({ endpoint: endpointUrl, activity: item.activity, graph: graph, date: item.date })\n                    })\n                })\n            });\n            return Promise.resolve(endpointTestsData);\n        })\n        .then(endpointTestsData => {\n            try {\n                let content = JSON.stringify(endpointTestsData);\n                return Global.writeFile(Global.getCachedFilenameForRunset(runset.id, endpointTestsDataFilename), content).then(() => {\n                    Logger.info(\"endpointTestsDataFill\", runset.id, \" END\")\n                    return Promise.resolve();\n                })\n            } catch (err) {\n                Logger.error(err)\n                return Promise.reject(err);\n            }\n        })\n        .catch(error => {\n            Logger.error(error)\n            return Promise.reject(error);\n        });\n}\n\nexport function totalRuntimeDataFill(runset: RunSetObject) {\n    Logger.info(\"totalRuntimeDataFill \", runset.id, \"START\")\n    let maxMinTimeQuery = `SELECT DISTINCT ?g ?endpointUrl ?date ?startTime ?endTime { \n        GRAPH ?g { \n            ?metadata <http://ns.inria.fr/kg/index#curated> ?curated .\n            ?metadata <http://ns.inria.fr/kg/index#trace> ?trace . \n            ?trace <http://www.w3.org/ns/prov#startedAtTime> ?startTime .\n            ?trace <http://www.w3.org/ns/prov#endedAtTime> ?endTime .\n            { ?curated <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . }\n            UNION { ?curated <http://www.w3.org/ns/dcat#endpointURL> ?endpointUrl . }\n            UNION { ?curated <http://rdfs.org/ns/void#sparqlEndpoint> ?endpointUrl . }\n        }\n        ${generateGraphValueFilterClause(runset.graphs)}\n    } `;\n    // ?metadata <http://purl.org/dc/terms/modified> ?date .\n    return Sparql.paginatedSparqlQueryToIndeGxPromise(maxMinTimeQuery).then(jsonResponse => {\n        let totalRuntimeData = [];\n        let graphEndpointMinStartDateMap: Map<string, Map<string, Dayjs>> = new Map();\n        let graphEndpointMaxStartDateMap: Map<string, Map<string, Dayjs>> = new Map();\n        (jsonResponse as JSONValue[]).forEach((itemResult, i) => {\n            let graph = itemResult[\"g\"].value.replace('http://ns.inria.fr/indegx#', '');\n            let date: Dayjs// = Global.parseDate(itemResult[\"date\"].value);\n            let rawDateUnderscoreIndex = graph.lastIndexOf(\"_\"); // Cheating on the date of the indexation\n            if (rawDateUnderscoreIndex != -1) {\n                let rawDate = graph.substring(rawDateUnderscoreIndex, graph.length);\n                date = Global.parseDate(rawDate, \"YYYYMMDD\");\n            }\n            let start = Global.parseDate(itemResult[\"startTime\"].value);\n            let end = Global.parseDate(itemResult[\"endTime\"].value);\n            let endpointUrl = itemResult[\"endpointUrl\"].value;\n            Logger.log(\"totalRuntimeDataFill\", runset.id, graph, endpointUrl, date.format(), start.format(), end.format())\n            if (!graphEndpointMinStartDateMap.has(graph)) {\n                graphEndpointMinStartDateMap.set(graph, new Map());\n            }\n            if (!graphEndpointMaxStartDateMap.has(graph)) {\n                graphEndpointMaxStartDateMap.set(graph, new Map());\n            }\n            if (!graphEndpointMinStartDateMap.get(graph).has(endpointUrl)) {\n                graphEndpointMinStartDateMap.get(graph).set(endpointUrl, start);\n            } else {\n                let previousStart = graphEndpointMinStartDateMap.get(graph).get(endpointUrl);\n                if (start.isBefore(previousStart)) {\n                    graphEndpointMinStartDateMap.get(graph).set(endpointUrl, start);\n                }\n            }\n            if (!graphEndpointMaxStartDateMap.get(graph).has(endpointUrl)) {\n                graphEndpointMaxStartDateMap.get(graph).set(endpointUrl, end);\n            } else {\n                let previousEnd = graphEndpointMaxStartDateMap.get(graph).get(endpointUrl);\n                if (end.isAfter(previousEnd)) {\n                    graphEndpointMaxStartDateMap.get(graph).set(endpointUrl, end);\n                }\n            }\n        });\n\n        graphEndpointMinStartDateMap.forEach((endpointMinStartDateMap, graph) => {\n            endpointMinStartDateMap.forEach((minStartDate, endpointUrl) => {\n                let maxStartDate = graphEndpointMaxStartDateMap.get(graph).get(endpointUrl);\n                let totalRuntime = maxStartDate.diff(minStartDate, 'second');\n                totalRuntimeData.push({ graph: graph, endpoint: endpointUrl, start: minStartDate, end: maxStartDate, runtime: totalRuntime });\n            })\n        })\n        return Promise.resolve(totalRuntimeData);\n    })\n        .then(totalRuntimeData => {\n            try {\n                let content = JSON.stringify(totalRuntimeData);\n                return Global.writeFile(Global.getCachedFilenameForRunset(runset.id, totalRuntimeDataFilename), content).then(() => {\n                    Logger.info(\"totalRuntimeDataFill\", runset.id, \" END\")\n                    return Promise.resolve();\n                });\n            } catch (err) {\n                Logger.error(err)\n                return Promise.reject(err);\n            }\n        })\n        .catch(error => {\n            Logger.error(error)\n            return Promise.reject(error);\n        });\n}\n\nexport function averageRuntimeDataFill(runset: RunSetObject) {\n    Logger.info(\"averageRuntimeDataFill\", runset.id, \" START\")\n    let maxMinTimeQuery = `SELECT DISTINCT ?g ?date (MIN(?startTime) AS ?start) (MAX(?endTime) AS ?end) { \n        GRAPH ?g {\n            ?metadata <http://ns.inria.fr/kg/index#curated> ?data , ?endpoint .\n            ?metadata <http://ns.inria.fr/kg/index#trace> ?trace .\n            ?trace <http://www.w3.org/ns/prov#startedAtTime> ?startTime .\n            ?trace <http://www.w3.org/ns/prov#endedAtTime> ?endTime .\n        }\n        ${generateGraphValueFilterClause(runset.graphs)}\n    }`;\n    // ?metadata <http://purl.org/dc/terms/modified> ?date .\n    let numberOfEndpointQuery = `SELECT DISTINCT ?g (COUNT(?endpointUrl) AS ?count) { \n        GRAPH ?g { \n            ?metadata <http://ns.inria.fr/kg/index#curated> ?endpoint , ?dataset . \n            { ?endpoint <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . } \n            UNION { ?dataset <http://rdfs.org/ns/void#sparqlEndpoint> ?endpointUrl . }\n        } \n        ${generateGraphValueFilterClause(runset.graphs)}\n    } GROUP BY ?g`;\n    let averageRuntimeData = [];\n    let graphStartEndMap = new Map();\n    return Promise.allSettled([\n        Sparql.paginatedSparqlQueryToIndeGxPromise(maxMinTimeQuery)\n            .then(jsonResponse => {\n                (jsonResponse as JSONValue[]).forEach((itemResult, i) => {\n                    let graph = itemResult[\"g\"].value.replace('http://ns.inria.fr/indegx#', '');\n                    let date: Dayjs; // = Global.parseDate(itemResult[\"date\"].value);\n                    let rawDateUnderscoreIndex = graph.lastIndexOf(\"_\"); // Cheating on the date of the indexation\n                    if (rawDateUnderscoreIndex != -1) {\n                        let rawDate = graph.substring(rawDateUnderscoreIndex, graph.length);\n                        date = Global.parseDate(rawDate, \"YYYYMMDD\");\n                    }\n                    let start = Global.parseDate(itemResult[\"start\"].value);\n                    let end = Global.parseDate(itemResult[\"end\"].value);\n                    let runtime = dayjs.duration(end.diff(start));\n\n                    if (graphStartEndMap.get(graph) == undefined) {\n                        graphStartEndMap.set(graph, {});\n                    }\n                    graphStartEndMap.get(graph).start = start;\n                    graphStartEndMap.get(graph).end = end;\n                    graphStartEndMap.get(graph).runtime = runtime;\n                    graphStartEndMap.get(graph).graph = graph;\n                    graphStartEndMap.get(graph).date = date;\n                })\n                return Promise.resolve();\n            }),\n        Sparql.paginatedSparqlQueryToIndeGxPromise(numberOfEndpointQuery)\n            .then(numberOfEndpointJson => {\n                (numberOfEndpointJson as JSONValue[]).forEach((numberEndpointItem, i) => {\n                    let graph = numberEndpointItem[\"g\"].value;\n                    graph = graph.replace('http://ns.inria.fr/indegx#', '');\n                    let count = numberEndpointItem[\"count\"].value;\n                    if (graphStartEndMap.get(graph) == undefined) {\n                        graphStartEndMap.set(graph, {});\n                    }\n                    graphStartEndMap.get(graph).count = count\n                    averageRuntimeData.push(graphStartEndMap.get(graph))\n                });\n                return Promise.resolve();\n            })\n    ])\n        .then(() => {\n            if (averageRuntimeData.length > 0) {\n                try {\n                    let content = JSON.stringify(averageRuntimeData);\n                    return Global.writeFile(Global.getCachedFilenameForRunset(runset.id, averageRuntimeDataFilename), content)\n                } catch (err) {\n                    Logger.error(err)\n                }\n            }\n            Logger.info(\"averageRuntimeDataFill\", runset.id, \" END\")\n            return Promise.resolve();\n        })\n        .catch(error => {\n            Logger.error(error)\n            return Promise.reject();\n        });\n}\n\nexport function classAndPropertiesDataFill(runset: RunSetObject) {\n    Logger.info(\"classAndPropertiesDataFill \", runset.id, \"START\")\n    let classPartitionQuery = `CONSTRUCT { ?classPartition <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl ;\n            <http://rdfs.org/ns/void#class> ?c ;\n            <http://rdfs.org/ns/void#triples> ?ct ;\n            <http://rdfs.org/ns/void#classes> ?cc ;\n            <http://rdfs.org/ns/void#properties> ?cp ;\n            <http://rdfs.org/ns/void#distinctSubjects> ?cs ;\n            <http://rdfs.org/ns/void#distinctObjects> ?co . \n    } WHERE { \n        GRAPH ?g { \n            ?metadata <http://ns.inria.fr/kg/index#curated> ?curated . \n            ?curated <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . \n            ?base <http://rdfs.org/ns/void#classPartition> ?classPartition . \n            ?classPartition <http://rdfs.org/ns/void#class> ?c . \n            OPTIONAL { ?classPartition <http://rdfs.org/ns/void#triples> ?ct . } \n            OPTIONAL { ?classPartition <http://rdfs.org/ns/void#classes> ?cc . }\n            OPTIONAL { ?classPartition <http://rdfs.org/ns/void#properties> ?cp . } \n            OPTIONAL { ?classPartition <http://rdfs.org/ns/void#distinctSubjects> ?cs . } \n            OPTIONAL { ?classPartition <http://rdfs.org/ns/void#distinctObjects> ?co . } \n            FILTER(! isBlank(?c)) \n        } \n        ${generateGraphValueFilterClause(runset.graphs)}\n    }`\n    let classSet = new Set();\n    let classCountsEndpointsMap = new Map();\n    let classPropertyCountsEndpointsMap = new Map();\n    let classContentData = [];\n    return Sparql.paginatedSparqlQueryToIndeGxPromise(classPartitionQuery)\n        .then(classPartitionStore => {\n            classPartitionStore = classPartitionStore as $rdf.Store;\n            let classStatements: $rdf.Statement[] = classPartitionStore.statementsMatching(null, RDFUtils.VOID(\"class\"), null);\n            classStatements.forEach((classStatement, i) => {\n                let c = classStatement.subject.value; //item.c.value;\n                classSet.add(c);\n                (classPartitionStore as $rdf.Store).statementsMatching(classStatement.subject, RDFUtils.SD(\"endpoint\"), null).forEach((classEndpointStatement, i) => {\n                    let endpointUrl = classEndpointStatement.object.value;\n                    if (classCountsEndpointsMap.get(c) == undefined) {\n                        classCountsEndpointsMap.set(c, { class: c });\n                    }\n                    classCountsEndpointsMap.get(c).endpoints.add(endpointUrl);\n                });\n                (classPartitionStore as $rdf.Store).statementsMatching(classStatement.subject, RDFUtils.VOID(\"triples\"), null).forEach((classTriplesStatement, i) => {\n                    let ct = Number.parseInt(classTriplesStatement.object.value);\n                    let currentClassItem = classCountsEndpointsMap.get(c);\n                    if (classCountsEndpointsMap.get(c).triples == undefined) {\n                        currentClassItem.triples = 0;\n                        classCountsEndpointsMap.set(c, currentClassItem);\n                    }\n                    currentClassItem.triples = currentClassItem.triples + ct;\n                    classCountsEndpointsMap.set(c, currentClassItem);\n                });\n                (classPartitionStore as $rdf.Store).statementsMatching(classStatement.subject, RDFUtils.VOID(\"classes\"), null).forEach((classClassesStatement, i) => {\n                    let cc = Number.parseInt(classClassesStatement.object.value);\n                    let currentClassItem = classCountsEndpointsMap.get(c);\n                    if (classCountsEndpointsMap.get(c).classes == undefined) {\n                        currentClassItem.classes = 0;\n                        classCountsEndpointsMap.set(c, currentClassItem);\n                    }\n                    currentClassItem.classes = currentClassItem.classes + cc;\n                    classCountsEndpointsMap.set(c, currentClassItem);\n                });\n                (classPartitionStore as $rdf.Store).statementsMatching(classStatement.subject, RDFUtils.VOID(\"properties\"), null).forEach((classPropertiesStatement, i) => {\n                    let cp = Number.parseInt(classPropertiesStatement.object.value);\n                    let currentClassItem = classCountsEndpointsMap.get(c);\n                    if (classCountsEndpointsMap.get(c).properties == undefined) {\n                        currentClassItem.properties = 0;\n                        classCountsEndpointsMap.set(c, currentClassItem);\n                    }\n                    currentClassItem.properties = currentClassItem.properties + cp;\n                    classCountsEndpointsMap.set(c, currentClassItem);\n                });\n                (classPartitionStore as $rdf.Store).statementsMatching(classStatement.subject, RDFUtils.VOID(\"distinctSubjects\"), null).forEach((classDistinctSubjectsStatement, i) => {\n                    let cs = Number.parseInt(classDistinctSubjectsStatement.object.value);\n                    let currentClassItem = classCountsEndpointsMap.get(c);\n                    if (classCountsEndpointsMap.get(c).distinctSubjects == undefined) {\n                        currentClassItem.distinctSubjects = 0;\n                        classCountsEndpointsMap.set(c, currentClassItem);\n                    }\n                    currentClassItem.distinctSubjects = currentClassItem.distinctSubjects + cs;\n                    classCountsEndpointsMap.set(c, currentClassItem);\n                });\n                (classPartitionStore as $rdf.Store).statementsMatching(classStatement.subject, RDFUtils.VOID(\"distinctObjects\"), null).forEach((classDistinctObjectsStatement, i) => {\n                    let co = Number.parseInt(classDistinctObjectsStatement.object.value);\n                    let currentClassItem = classCountsEndpointsMap.get(c);\n                    if (classCountsEndpointsMap.get(c).distinctObjects == undefined) {\n                        currentClassItem.distinctObjects = 0;\n                        classCountsEndpointsMap.set(c, currentClassItem);\n                    }\n                    currentClassItem.distinctObjects = currentClassItem.distinctObjects + co;\n                    classCountsEndpointsMap.set(c, currentClassItem);\n                });\n                if (classCountsEndpointsMap.get(c).endpoints == undefined) {\n                    let currentClassItem = classCountsEndpointsMap.get(c);\n                    currentClassItem.endpoints = new Set();\n                    classCountsEndpointsMap.set(c, currentClassItem);\n                }\n            });\n            return Promise.resolve();\n        })\n        .then(() => {\n            let classPropertyPartitionQuery = `CONSTRUCT {\n                ?classPropertyPartition <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl  ;\n                    <http://rdfs.org/ns/void#class> ?c ;\n                    <http://rdfs.org/ns/void#property> ?p ;\n                    <http://rdfs.org/ns/void#triples> ?pt ;\n                    <http://rdfs.org/ns/void#distinctSubjects> ?ps ;\n                    <http://rdfs.org/ns/void#distinctObjects> ?po .\n            } { \n                GRAPH ?g {\n                    ?endpoint <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . \n                    ?metadata <http://ns.inria.fr/kg/index#curated> ?endpoint , ?base . \n                    ?base <http://rdfs.org/ns/void#classPartition> ?classPartition . \n                    ?classPartition <http://rdfs.org/ns/void#class> ?c . \n                    ?classPartition <http://rdfs.org/ns/void#propertyPartition> ?classPropertyPartition . \n                    ?classPropertyPartition <http://rdfs.org/ns/void#property> ?p . \n                    OPTIONAL { ?classPropertyPartition <http://rdfs.org/ns/void#triples> ?pt . } \n                    OPTIONAL { ?classPropertyPartition <http://rdfs.org/ns/void#distinctSubjects> ?ps . } \n                    OPTIONAL { ?classPropertyPartition <http://rdfs.org/ns/void#distinctObjects> ?po . } \n                    FILTER(! isBlank(?c)) \n                }\n                ${generateGraphValueFilterClause(runset.graphs)}\n            }`;\n            return Sparql.paginatedSparqlQueryToIndeGxPromise(classPropertyPartitionQuery).then(classPropertyStore => {\n                classPropertyStore = classPropertyStore as $rdf.Store;\n                (classPropertyStore as $rdf.Store).statementsMatching(null, RDFUtils.VOID(\"class\"), null).forEach((classPropertyStatement, i) => {\n                    let partitionNode = classPropertyStatement.subject;\n                    let c = classPropertyStatement.object.value;\n                    classSet.add(c);\n                    if (classPropertyCountsEndpointsMap.get(c) == undefined) {\n                        classPropertyCountsEndpointsMap.set(c, new Map());\n                    }\n                    (classPropertyStore as $rdf.Store).statementsMatching(partitionNode, RDFUtils.VOID(\"property\"), null).forEach((propertyStatement, i) => {\n                        let p = propertyStatement.object.value;\n                        if (classPropertyCountsEndpointsMap.get(c).get(p) == undefined) {\n                            classPropertyCountsEndpointsMap.get(c).set(p, { property: p });\n                        }\n                        (classPropertyStore as $rdf.Store).statementsMatching(partitionNode, RDFUtils.SD(\"endpoint\"), null).forEach((endpointStatement, i) => {\n                            let endpointUrl = endpointStatement.object.value;\n                            if (classPropertyCountsEndpointsMap.get(c).get(p).endpoints == undefined) {\n                                classPropertyCountsEndpointsMap.get(c).get(p).endpoints = new Set();\n                            }\n                            classPropertyCountsEndpointsMap.get(c).get(p).endpoints.add(endpointUrl);\n                        });\n                        (classPropertyStore as $rdf.Store).statementsMatching(partitionNode, RDFUtils.VOID(\"triples\"), null).forEach((triplesStatement, i) => {\n                            let pt = Number.parseInt(triplesStatement.object.value);\n                            if (classPropertyCountsEndpointsMap.get(c).get(p).triples == undefined) {\n                                classPropertyCountsEndpointsMap.get(c).get(p).triples = 0;\n                            }\n                            classPropertyCountsEndpointsMap.get(c).get(p).triples = classPropertyCountsEndpointsMap.get(c).get(p).triples + pt;\n                        });\n                        (classPropertyStore as $rdf.Store).statementsMatching(partitionNode, RDFUtils.VOID(\"distinctSubjects\"), null).forEach((distinctSubjectsStatement, i) => {\n                            let ps = Number.parseInt(distinctSubjectsStatement.object.value);\n                            if (classPropertyCountsEndpointsMap.get(c).get(p).distinctSubjects == undefined) {\n                                classPropertyCountsEndpointsMap.get(c).get(p).distinctSubjects = 0;\n                            }\n                            classPropertyCountsEndpointsMap.get(c).get(p).distinctSubjects = classPropertyCountsEndpointsMap.get(c).get(p).distinctSubjects + ps;\n                        });\n                        (classPropertyStore as $rdf.Store).statementsMatching(partitionNode, RDFUtils.VOID(\"distinctObjects\"), null).forEach((distinctObjectsStatement, i) => {\n                            let po = Number.parseInt(distinctObjectsStatement.object.value);\n                            if (classPropertyCountsEndpointsMap.get(c).get(p).distinctObjects == undefined) {\n                                classPropertyCountsEndpointsMap.get(c).get(p).distinctObjects = 0;\n                            }\n                            classPropertyCountsEndpointsMap.get(c).get(p).distinctObjects = classPropertyCountsEndpointsMap.get(c).get(p).distinctObjects + po;\n                        });\n                    })\n                });\n                return Promise.resolve();\n            });\n        })\n        .then(() => {\n            classSet.forEach(className => {\n                let classCountItem = classCountsEndpointsMap.get(className);\n                let classItem = classCountItem;\n                if (classCountItem == undefined) {\n                    classItem = { class: className };\n                }\n                if (classItem.endpoints != undefined) {\n                    classItem.endpoints = [...classItem.endpoints]\n                }\n                let classPropertyItem = classPropertyCountsEndpointsMap.get(className);\n                if (classPropertyItem != undefined) {\n                    classItem.propertyPartitions = [];\n                    classPropertyItem.forEach((propertyPartitionItem, propertyName, map1) => {\n                        propertyPartitionItem.endpoints = [...propertyPartitionItem.endpoints]\n                        classItem.propertyPartitions.push(propertyPartitionItem);\n                    });\n                }\n                classContentData.push(classItem)\n            })\n            try {\n                let content = JSON.stringify(classContentData);\n                return Global.writeFile(Global.getCachedFilenameForRunset(runset.id, classPropertyDataFilename), content).then(() => {\n                    Logger.info(\"classAndPropertiesDataFill\", runset.id, \" END\")\n                    return Promise.resolve();\n                })\n            } catch (err) {\n                Logger.error(err)\n                return Promise.reject(err);\n            }\n        })\n        .catch(error => {\n            Logger.error(error)\n            return Promise.reject(error);\n        })\n}\n\nexport function datasetDescriptionDataFill(runset: RunSetObject) {\n    Logger.info(\"datasetDescriptionDataDataFill\", runset.id, \" START\")\n    let provenanceWhoCheckQuery = `SELECT DISTINCT ?endpointUrl ?o { \n        GRAPH ?g { \n            ?metadata <http://ns.inria.fr/kg/index#curated> ?dataset . \n            { ?dataset <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . } \n            UNION { ?dataset <http://www.w3.org/ns/dcat#endpointURL> ?endpointUrl }\n            UNION { ?dataset <http://rdfs.org/ns/void#sparqlEndpoint> ?endpointUrl }\n            OPTIONAL {\n                { ?dataset <http://purl.org/dc/terms/creator> ?o }\n                UNION { ?dataset <http://purl.org/dc/terms/contributor> ?o }\n                UNION { ?dataset <http://purl.org/dc/terms/publisher> ?o }\n            }\n        }\n        ${generateGraphValueFilterClause(runset.graphs)}\n    }`;\n    let provenanceLicenseCheckQuery = `SELECT DISTINCT ?endpointUrl ?o { \n        GRAPH ?g {\n            ?metadata <http://ns.inria.fr/kg/index#curated> ?dataset .\n            { ?dataset <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . }\n            UNION { ?dataset <http://www.w3.org/ns/dcat#endpointURL> ?endpointUrl } \n            UNION { ?dataset <http://rdfs.org/ns/void#sparqlEndpoint> ?endpointUrl }\n            OPTIONAL {\n                { ?dataset <http://purl.org/dc/terms/license> ?o } \n                UNION {?dataset <http://purl.org/dc/terms/conformsTo> ?o }\n            } \n        }\n        ${generateGraphValueFilterClause(runset.graphs)}\n    } `;\n    let provenanceDateCheckQuery = `SELECT DISTINCT ?endpointUrl ?o { \n        GRAPH ?g { \n            ?metadata <http://ns.inria.fr/kg/index#curated> ?dataset . \n            { ?dataset <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . }\n            UNION { ?dataset <http://www.w3.org/ns/dcat#endpointURL> ?endpointUrl }\n            UNION { ?dataset <http://rdfs.org/ns/void#sparqlEndpoint> ?endpointUrl }\n            OPTIONAL {\n                { ?dataset <http://purl.org/dc/terms/modified> ?o }\n                UNION { ?dataset <http://www.w3.org/ns/prov#wasGeneratedAtTime> ?o } \n                UNION { ?dataset <http://purl.org/dc/terms/issued> ?o }\n            }\n        }\n        ${generateGraphValueFilterClause(runset.graphs)}\n    } `;\n    let provenanceSourceCheckQuery = `SELECT DISTINCT ?endpointUrl ?o {\n        GRAPH ?g {\n            ?metadata <http://ns.inria.fr/kg/index#curated> ?dataset .\n            { ?dataset <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . }\n            UNION { ?dataset <http://www.w3.org/ns/dcat#endpointURL> ?endpointUrl }\n            UNION { ?dataset <http://rdfs.org/ns/void#sparqlEndpoint> ?endpointUrl }\n            OPTIONAL {\n                { ?dataset <http://purl.org/dc/terms/source> ?o } \n                UNION { ?dataset <http://www.w3.org/ns/prov#wasDerivedFrom> ?o }\n                UNION { ?dataset <http://purl.org/dc/terms/format> ?o }\n            }\n        }\n        ${generateGraphValueFilterClause(runset.graphs)}\n    } `;\n    let endpointDescriptionElementMap = new Map();\n    return Promise.allSettled([\n        Sparql.paginatedSparqlQueryToIndeGxPromise(provenanceWhoCheckQuery)\n            .then(json => {\n                (json as JSONValue[]).forEach((item, i) => {\n                    let endpointUrl = item[\"endpointUrl\"].value;\n                    let who = (item[\"o\"] != undefined);\n                    let currentEndpointItem = endpointDescriptionElementMap.get(endpointUrl)\n                    if (currentEndpointItem == undefined) {\n                        endpointDescriptionElementMap.set(endpointUrl, { endpoint: endpointUrl })\n                        currentEndpointItem = endpointDescriptionElementMap.get(endpointUrl);\n                    }\n                    currentEndpointItem.who = who;\n                    if (who) {\n                        currentEndpointItem.whoValue = item[\"o\"].value;\n                    }\n                    endpointDescriptionElementMap.set(endpointUrl, currentEndpointItem);\n                })\n                return Promise.resolve();\n            }),\n        Sparql.paginatedSparqlQueryToIndeGxPromise(provenanceLicenseCheckQuery)\n            .then(json => {\n                (json as JSONValue[]).forEach((item, i) => {\n                    let endpointUrl = item[\"endpointUrl\"].value;\n                    let license = (item[\"o\"] != undefined);\n                    let currentEndpointItem = endpointDescriptionElementMap.get(endpointUrl)\n                    if (currentEndpointItem == undefined) {\n                        endpointDescriptionElementMap.set(endpointUrl, { endpoint: endpointUrl })\n                        currentEndpointItem = endpointDescriptionElementMap.get(endpointUrl);\n                    }\n                    currentEndpointItem.license = license;\n                    if (license) {\n                        currentEndpointItem.licenseValue = item[\"o\"].value;\n                    }\n                    endpointDescriptionElementMap.set(endpointUrl, currentEndpointItem);\n                })\n                return Promise.resolve();\n            })\n            .catch(error => {\n                Logger.error(error)\n                return Promise.reject(error);\n            })\n        ,\n        Sparql.paginatedSparqlQueryToIndeGxPromise(provenanceDateCheckQuery)\n            .then(json => {\n                (json as JSONValue[]).forEach((item, i) => {\n                    let endpointUrl = item[\"endpointUrl\"].value;\n                    let time = (item[\"o\"] != undefined);\n                    let currentEndpointItem = endpointDescriptionElementMap.get(endpointUrl)\n                    if (currentEndpointItem == undefined) {\n                        endpointDescriptionElementMap.set(endpointUrl, { endpoint: endpointUrl })\n                        currentEndpointItem = endpointDescriptionElementMap.get(endpointUrl);\n                    }\n                    currentEndpointItem.time = time;\n                    if (time) {\n                        currentEndpointItem.timeValue = item[\"o\"].value;\n                    }\n                    endpointDescriptionElementMap.set(endpointUrl, currentEndpointItem);\n                })\n                return Promise.resolve();\n            })\n            .catch(error => {\n                Logger.error(error)\n                return Promise.reject(error);\n            })\n        ,\n        Sparql.paginatedSparqlQueryToIndeGxPromise(provenanceSourceCheckQuery)\n            .then(json => {\n                (json as JSONValue[]).forEach((item, i) => {\n                    let endpointUrl = item[\"endpointUrl\"].value;\n                    let source = (item[\"o\"] != undefined);\n                    let currentEndpointItem = endpointDescriptionElementMap.get(endpointUrl)\n                    if (currentEndpointItem == undefined) {\n                        endpointDescriptionElementMap.set(endpointUrl, { endpoint: endpointUrl })\n                        currentEndpointItem = endpointDescriptionElementMap.get(endpointUrl);\n                    }\n                    currentEndpointItem.source = source;\n                    if (source) {\n                        currentEndpointItem.sourceValue = item[\"o\"].value;\n                    }\n                    endpointDescriptionElementMap.set(endpointUrl, currentEndpointItem);\n                });\n                return Promise.resolve();\n            })\n            .catch(error => {\n                Logger.error(error)\n                return Promise.reject(error);\n            })\n    ]).then(() => {\n\n        let datasetDescriptionData = [];\n        endpointDescriptionElementMap.forEach((prov, endpoint, map) => {\n            datasetDescriptionData.push(prov)\n        });\n        return Promise.resolve(datasetDescriptionData);\n    })\n        .then(datasetDescriptionData => {\n            try {\n                let content = JSON.stringify(datasetDescriptionData);\n                return Global.writeFile(Global.getCachedFilenameForRunset(runset.id, datasetDescriptionDataFilename), content).then(() => {\n                    Logger.info(\"datasetDescriptionDataDataFill\", runset.id, \" END\")\n                    return Promise.resolve();\n                });\n            } catch (err) {\n                Logger.error(err)\n            }\n        })\n        .catch(error => {\n            Logger.error(error)\n            return Promise.reject(error);\n        });\n}\n\nexport function shortUrisDataFill(runset: RunSetObject) {\n    Logger.info(\"shortUrisDataFill\", runset.id, \" START\")\n    let shortUrisMeasureQuery = `SELECT DISTINCT ?g ?date ?endpointUrl ?measure {\n            GRAPH ?g {\n                { ?curated <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . } \n                UNION { ?curated <http://rdfs.org/ns/void#sparqlEndpoint> ?endpointUrl . } \n                ?metadata <http://ns.inria.fr/kg/index#curated> ?curated .\n                ?metadata <http://www.w3.org/ns/dqv#hasQualityMeasurement> ?measureNode .\n                ?measureNode <http://www.w3.org/ns/dqv#isMeasurementOf> <https://raw.githubusercontent.com/Wimmics/dekalog/master/rules/check/shortUris.ttl> .\n                ?measureNode <http://www.w3.org/ns/dqv#value> ?measure .\n            }\n            ${generateGraphValueFilterClause(runset.graphs)}\n        } GROUP BY ?g ?date ?endpointUrl ?measure`;\n    // ?metadata <http://purl.org/dc/terms/modified> ?date . \n    return Sparql.paginatedSparqlQueryToIndeGxPromise(shortUrisMeasureQuery)\n        .then(json => {\n            let shortUriData = []\n            let graphSet = new Set();\n            (json as JSONValue[]).forEach((jsonItem, i) => {\n                let endpoint = jsonItem[\"endpointUrl\"].value;\n                let shortUriMeasure = Number.parseFloat(Global.precise(Number.parseFloat(jsonItem[\"measure\"].value) * 100));\n                let graph = jsonItem[\"g\"].value.replace(\"http://ns.inria.fr/indegx#\", \"\");\n                let date: Dayjs // = Global.parseDate(jsonItem[\"date\"].value);\n                let rawDateUnderscoreIndex = graph.lastIndexOf(\"_\"); // Cheating on the date of the indexation\n                if (rawDateUnderscoreIndex != -1) {\n                    let rawDate = graph.substring(rawDateUnderscoreIndex, graph.length);\n                    date = Global.parseDate(rawDate, \"YYYYMMDD\");\n                }\n\n                graphSet.add(graph);\n                shortUriData.push({ graph: graph, date: date, endpoint: endpoint, measure: shortUriMeasure })\n            });\n            return Promise.resolve(shortUriData);\n        })\n        .then(shortUriData => {\n            if (shortUriData.length > 0) {\n                try {\n                    let content = JSON.stringify(shortUriData);\n                    fs.writeFileSync(Global.getCachedFilenameForRunset(runset.id, shortUriDataFilename), content)\n                } catch (err) {\n                    Logger.error(err)\n                }\n            }\n            Logger.info(\"shortUrisDataFill\", runset.id, \" END\")\n            return Promise.resolve();\n        })\n        .catch(error => {\n            Logger.error(error)\n            return Promise.reject(error);\n        });\n}\n\nexport function readableLabelsDataFill(runset: RunSetObject) {\n    Logger.info(\"readableLabelsDataFill\", runset.id, \" START\")\n    let readableLabelsQuery = `SELECT DISTINCT ?g ?date ?endpointUrl ?measure { \n            GRAPH ?g {\n                { ?curated <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . }\n                UNION { ?curated <http://rdfs.org/ns/void#sparqlEndpoint> ?endpointUrl . } \n                ?metadata <http://ns.inria.fr/kg/index#curated> ?curated . \n                ?metadata <http://www.w3.org/ns/dqv#hasQualityMeasurement> ?measureNode . \n                ?measureNode <http://www.w3.org/ns/dqv#isMeasurementOf> <https://raw.githubusercontent.com/Wimmics/dekalog/master/rules/check/readableLabels.ttl> . \n                ?measureNode <http://www.w3.org/ns/dqv#value> ?measure . \n            } \n            ${generateGraphValueFilterClause(runset.graphs)}\n        } GROUP BY ?g ?date ?endpointUrl ?measure`;\n    // ?metadata <http://purl.org/dc/terms/modified> ?date . \n\n    return Sparql.paginatedSparqlQueryToIndeGxPromise(readableLabelsQuery)\n        .then(json => {\n            let readableLabelData = [];\n            (json as JSONValue[]).forEach((jsonItem, i) => {\n                let endpoint = jsonItem[\"endpointUrl\"].value;\n                let readableLabelMeasure = Number.parseFloat(Global.precise(Number.parseFloat(jsonItem[\"measure\"].value) * 100));\n                let graph = jsonItem[\"g\"].value.replace(\"http://ns.inria.fr/indegx#\", \"\");\n                let date: Dayjs; // = Global.parseDate(jsonItem[\"date\"].value);\n                let rawDateUnderscoreIndex = graph.lastIndexOf(\"_\"); // Cheating on the date of the indexation\n                if (rawDateUnderscoreIndex != -1) {\n                    let rawDate = graph.substring(rawDateUnderscoreIndex, graph.length);\n                    date = Global.parseDate(rawDate, \"YYYYMMDD\");\n                }\n\n                readableLabelData.push({ graph: graph, date: date, endpoint: endpoint, measure: readableLabelMeasure })\n            });\n            return Promise.resolve(readableLabelData);\n        })\n        .then(readableLabelData => {\n            if (readableLabelData.length > 0) {\n                try {\n                    let content = JSON.stringify(readableLabelData);\n                    return Global.writeFile(Global.getCachedFilenameForRunset(runset.id, readableLabelDataFilename), content).then(() => {\n                        Logger.info(\"readableLabelsDataFill\", runset.id, \" END\")\n                        return Promise.resolve();\n                    });\n                } catch (err) {\n                    Logger.error(err)\n                }\n            }\n            return Promise.resolve();\n        })\n        .catch(error => {\n            Logger.error(error);\n            return Promise.reject(error);\n        });\n}\n\nexport function rdfDataStructureDataFill(runset: RunSetObject) {\n    Logger.info(\"rdfDataStructureDataFill\", runset.id, \" START\")\n    let rdfDataStructureQuery = `SELECT DISTINCT ?g ?date ?endpointUrl ?measure { \n            GRAPH ?g {\n                { ?curated <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . } \n                UNION { ?curated <http://rdfs.org/ns/void#sparqlEndpoint> ?endpointUrl . } \n                ?metadata <http://ns.inria.fr/kg/index#curated> ?curated . \n                ?metadata <http://www.w3.org/ns/dqv#hasQualityMeasurement> ?measureNode . \n                ?measureNode <http://www.w3.org/ns/dqv#isMeasurementOf> <https://raw.githubusercontent.com/Wimmics/dekalog/master/rules/check/RDFDataStructures.ttl> . \n                ?measureNode <http://www.w3.org/ns/dqv#value> ?measure . \n            }\n            ${generateGraphValueFilterClause(runset.graphs)}\n        } \n        GROUP BY ?g ?date ?endpointUrl ?measure` ;\n    // ?metadata <http://purl.org/dc/terms/modified> ?date . \n\n    return Sparql.paginatedSparqlQueryToIndeGxPromise(rdfDataStructureQuery).then(json => {\n        let rdfDataStructureData = [];\n        (json as JSONValue[]).forEach((jsonItem, i) => {\n            let endpoint = jsonItem[\"endpointUrl\"].value;\n            let rdfDataStructureMeasure = Number.parseFloat(Global.precise(Number.parseFloat(jsonItem[\"measure\"].value) * 100));\n            let graph = jsonItem[\"g\"].value.replace(\"http://ns.inria.fr/indegx#\", \"\");\n            let date: Dayjs;// = Global.parseDate(jsonItem[\"date\"].value);\n            let rawDateUnderscoreIndex = graph.lastIndexOf(\"_\"); // Cheating on the date of the indexation\n            if (rawDateUnderscoreIndex != -1) {\n                let rawDate = graph.substring(rawDateUnderscoreIndex, graph.length);\n                date = Global.parseDate(rawDate, \"YYYYMMDD\");\n            }\n\n            rdfDataStructureData.push({ graph: graph, date: date, endpoint: endpoint, measure: rdfDataStructureMeasure })\n        });\n        return Promise.resolve(rdfDataStructureData);\n    })\n        .then(rdfDataStructureData => {\n            try {\n                let content = JSON.stringify(rdfDataStructureData);\n                return Global.writeFile(Global.getCachedFilenameForRunset(runset.id, rdfDataStructureDataFilename), content).then(() => {\n                    Logger.info(\"rdfDataStructureDataFill\", runset.id, \" END\");\n                    return;\n                })\n\n            } catch (err) {\n                Logger.error(err)\n            }\n            return Promise.resolve();\n        })\n        .catch(error => {\n            Logger.error(error);\n        });\n}\n\nexport function blankNodeDataFill(runset: RunSetObject) {\n    Logger.info(\"blankNodeDataFill\", runset.id, \" START\")\n    let blankNodeQuery = `PREFIX dcat: <http://www.w3.org/ns/dcat#>\n        PREFIX dct: <http://purl.org/dc/terms/>\n        PREFIX sd: <http://www.w3.org/ns/sparql-service-description#>\n        PREFIX void: <http://rdfs.org/ns/void#>\n        PREFIX kgi: <http://ns.inria.fr/kg/index#>\n        PREFIX dqv: <http://www.w3.org/ns/dqv#>\n        SELECT DISTINCT ?g ?date ?endpointUrl ?measure { \n            GRAPH ?g {\n                ?metadata kgi:curated ?curated . \n                { ?curated sd:endpoint ?endpointUrl . } \n                UNION { ?curated void:sparqlEndpoint ?endpointUrl . } \n                UNION { ?curated dcat:endpointURL ?endpointUrl . } \n    \t\t\t{ ?metadata dqv:hasQualityMeasurement ?measureNode . }\n    \t\t\tUNION { ?curated dqv:hasQualityMeasurement ?measureNode . }\n                ?measureNode dqv:isMeasurementOf <https://raw.githubusercontent.com/Wimmics/dekalog/master/rules/check/blankNodeUsage.ttl> . \n                ?measureNode dqv:value ?measure . \n            }\n            ${generateGraphValueFilterClause(runset.graphs)}\n        } \n        GROUP BY ?g ?date ?endpointUrl ?measure` ;\n    // { ?metadata dct:modified ?date . }\n    // UNION { ?curated dct:modified ?date }\n    return Sparql.sparqlQueryToIndeGxPromise(blankNodeQuery).then(json => {\n\n        let blankNodeData = []\n        let graphSet = new Set();\n        let graphEndpointDateMeasureMap: Map<string, Map<string, Map<string, number>>> = new Map();\n        (json as SPARQLJSONResult).results.bindings.forEach((jsonItem, i) => {\n            let endpoint = jsonItem.endpointUrl.value;\n            let blankNodeMeasure = Number.parseFloat(Global.precise(Number.parseFloat(jsonItem.measure.value) * 100));\n            let graph = jsonItem.g.value.replace(\"http://ns.inria.fr/indegx#\", \"\");\n            let rawDate: Dayjs; //= Global.parseDate(jsonItem.date.value);\n            let rawDateUnderscoreIndex = graph.lastIndexOf(\"_\"); // Cheating on the date of the indexation\n            if (rawDateUnderscoreIndex != -1) {\n                let rawRawDate = graph.substring(rawDateUnderscoreIndex, graph.length);\n                rawDate = Global.parseDate(rawRawDate, \"YYYYMMDD\");\n            }\n            let date = rawDate.format(\"YYYY-MM-DD\");\n\n            if (!graphEndpointDateMeasureMap.has(graph)) {\n                graphEndpointDateMeasureMap.set(graph, new Map());\n            }\n            if (!graphEndpointDateMeasureMap.get(graph).has(endpoint)) {\n                graphEndpointDateMeasureMap.get(graph).set(endpoint, new Map());\n            }\n            if (!graphEndpointDateMeasureMap.get(graph).get(endpoint).has(date)) {\n                graphEndpointDateMeasureMap.get(graph).get(endpoint).set(date, blankNodeMeasure);\n            }\n            if (graphEndpointDateMeasureMap.get(graph).get(endpoint).has(date) && graphEndpointDateMeasureMap.get(graph).get(endpoint).get(date) < blankNodeMeasure) {\n                graphEndpointDateMeasureMap.get(graph).get(endpoint).set(date, blankNodeMeasure);\n            }\n            graphSet.add(graph);\n        });\n\n        graphEndpointDateMeasureMap.forEach((endpointDateMeasureMap, graph) => {\n            endpointDateMeasureMap.forEach((dateMeasureMap, endpoint) => {\n                dateMeasureMap.forEach((measure, date) => {\n                    blankNodeData.push({ graph: graph, date: date, endpoint: endpoint, measure: measure })\n                })\n            })\n        })\n\n        return Promise.resolve(blankNodeData);\n    })\n        .then(blankNodeData => {\n            try {\n                let content = JSON.stringify(blankNodeData);\n                return Global.writeFile(Global.getCachedFilenameForRunset(runset.id, blankNodesDataFilename), content).then(() => {\n                    Logger.info(\"blankNodeDataFill\", runset.id, \" END\");\n                    return Promise.resolve();\n                })\n            } catch (err) {\n                Logger.error(err)\n            }\n            return Promise.reject();\n        })\n        .catch(error => {\n            Logger.error(error)\n        });\n}","import fetch, { FetchError, RequestInit, Headers } from 'node-fetch';\nimport * as fs from 'node:fs/promises';\nimport { setTimeout } from 'node:timers/promises';\nimport dayjs from \"dayjs\";\nimport * as Logger from \"./LogUtils\"\nimport { JSONValue } from './DataTypes';\nimport * as DataCache from \"./DataCaching\";\n\nexport let nbFetchRetries = 10;\nexport let millisecondsBetweenRetries = 5000;\nlet countConcurrentQueries = 0;\nexport let maxConccurentQueries = 300;\nexport let delayMillisecondsTimeForConccurentQuery = 1000\n\nexport function getCachedFilenameForRunset(runsetId: string, filename: string) {\n    return DataCache.dataCachedFilePrefix + filename + \".\" + runsetId + \".json\";\n}\n\n\n// Parse the date in any format\nexport function parseDate(input: string, format: string = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\") {\n    let result = dayjs(input, format);\n    if((format.localeCompare(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\") == 0) && ! result.isValid()) {\n        result = parseDate(input, \"dd-MM-yyyy'T'HH:mm:ss.SSS'Z'\");\n    } else if(format.localeCompare(\"dd-MM-yyyy'T'HH:mm:ss.SSS'Z'\") && ! result.isValid()) {\n        result = parseDate(input, \"yyyy-MM-dd'T'HH:mm:ss\");\n    } else if(format.localeCompare(\"yyyy-MM-dd'T'HH:mm:ss\") && ! result.isValid()) {\n        result = parseDate(input, \"dd-MM-yyyy'T'HH:mm:ss\");\n    } else if(format.localeCompare(\"dd-MM-yyyy'T'HH:mm:ss\") && ! result.isValid()) { \n        result = parseDate(input, \"dd-MM-yyyy'T'HH:mm:ss.SSSXXX\");\n    } else if(format.localeCompare(\"dd-MM-yyyy'T'HH:mm:ss.SSSXXX\") && ! result.isValid()) {\n        result = parseDate(input, \"dd-MM-yyyy'T'HH:mm:ssXXX\");\n    }\n    return result;\n}\n\nexport function getCountConccurentQueries() {\n    return countConcurrentQueries;\n}\n\nexport function setNbFetchRetries(nb: number) {\n    if (nb !== undefined && nb !== null && nb >= 0) {\n        nbFetchRetries = nb;\n    } else {\n        throw new Error(\"The number of retries must be a positive integer\");\n    }\n}\n\nexport function setMillisecondsBetweenRetries(milliseconds: number) {\n    if (milliseconds !== undefined && milliseconds !== null && milliseconds >= 0) {\n        millisecondsBetweenRetries = milliseconds;\n    } else {\n        throw new Error(\"The number of milliseconds between retries must be a positive integer\");\n    }\n}\n\nexport function setMaxConccurentQueries(max: number) {\n    if (max !== undefined && max !== null && max >= 0) {\n        maxConccurentQueries = max;\n    } else {\n        throw new Error(\"The number of maximum concurrent queries must be a positive integer\");\n    }\n}\n\nexport function setDelayMillisecondsTimeForConccurentQuery(milliseconds: number) {\n    if (milliseconds !== undefined && milliseconds !== null && milliseconds >= 0) {\n        delayMillisecondsTimeForConccurentQuery = milliseconds;\n    } else {\n        throw new Error(\"The number of milliseconds between queries must be a positive integer\");\n    }\n}\n\nexport function appendToFile(filename, content) {\n    return fs.writeFile(filename, content, { flag: 'a+' }).catch(error => {\n        Logger.error(\"Error appending to file\", error)\n    });\n}\n\nexport function writeFile(filename, content) {\n    return fs.writeFile(filename, content).catch(error => {\n        Logger.error(\"Error writing to file\", filename, error)\n    });\n}\n\nexport function readFile(filename: string): Promise<string> {\n    let readFilePromise: Promise<string>;\n    if (filename.startsWith(\"http://\") || filename.startsWith(\"https://\")) {\n        readFilePromise = fetchGETPromise(filename)\n    } else if (filename.startsWith(\"file://\")) {\n        readFilePromise = fs.readFile(filename.replace(\"file://\", \"\")).then(buffer => buffer.toString())\n    } else {\n        readFilePromise = fs.readFile(filename).then(buffer => buffer.toString())\n    }\n    return readFilePromise;\n}\n\nexport function readJSONFile(filename: string): Promise<JSONValue> {\n    return readFile(filename).then(content => JSON.parse(content));\n}\n\nexport function extractSettledPromiseValues(settledPromisesResult: PromiseSettledResult<any>[]) {\n    return settledPromisesResult.map(promiseResult => {\n        if (promiseResult.status === \"fulfilled\") {\n            return promiseResult.value;\n        } else {\n            return undefined;\n        }\n    });\n}\n\ntype promiseCreationFunction = {\n    (...args: any[]): Promise<any>;\n}\n\n/**\n * Execute promises iteratively, on the opposite to Promise.all, which execute promises in parallel.\n * @param args Array of the arguments to pass to the promiseCreationFunction. Each element of the array is an array of arguments to pass to the promiseCreationFunction.\n * @param promiseCreationFunction A function generating a promise from the elements in the args arrays.\n * @returns a promise resolved when all the promises created by the promiseCreationFunction are resolved.\n */\nexport function iterativePromises(args: Array<Array<any>>, promiseCreationFunction: promiseCreationFunction): Promise<any> {\n    let argsCopy = args.map(arg => arg);\n    if (argsCopy.length > 0) {\n        return promiseCreationFunction.apply(this, argsCopy[0]).then(() => {\n            argsCopy.shift();\n            return iterativePromises(argsCopy, promiseCreationFunction);\n        })\n    }\n    return new Promise<void>((resolve, reject) => resolve());\n}\n\nexport function fetchPromise(url, header = new Map(), method = \"GET\", query = \"\", numTry = 0) {\n    let myHeaders = new Headers();\n    myHeaders.set('pragma', 'no-cache');\n    myHeaders.set('cache-control', 'no-cache');\n    header.forEach((value, key) => {\n        myHeaders.set(key, value);\n    });\n    let myInit: RequestInit = {\n        method: method,\n        headers: myHeaders,\n        redirect: 'follow',\n    };\n    if (method.localeCompare(\"POST\") == 0) {\n        myInit.body = query;\n    }\n    if (countConcurrentQueries >= maxConccurentQueries) {\n        return setTimeout(delayMillisecondsTimeForConccurentQuery).then(() => fetchPromise(url, header, method, query, numTry))\n    } else {\n        countConcurrentQueries++;\n        return fetch(url, myInit)\n            .then(response => {\n                if (response.ok) {\n                    return response.blob().then(blob => blob.text())\n                } else {\n                    throw response;\n                }\n            }).catch(error => {\n                if (error instanceof FetchError) {\n                    Logger.error(error.type, error.message)\n                    Logger.info(\"Try:\", numTry, \"Fetch \", method, url, query);\n                    if (numTry < nbFetchRetries) {\n                        return setTimeout(millisecondsBetweenRetries).then(fetchPromise(url, header, method, query, numTry + 1));\n                    } else {\n                        Logger.error(\"Too many retries\", error);\n                    }\n                } else {\n                    Logger.error(\"FetchError, try n\", numTry, error);\n                }\n            }).finally(() => {\n                countConcurrentQueries--;\n                return;\n            });\n\n    }\n}\n\nexport function fetchGETPromise(url: string, header = new Map()): Promise<string> {\n    return fetchPromise(url, header);\n}\n\nexport function fetchPOSTPromise(url: string, query = \"\", header = new Map()): Promise<string> {\n    return fetchPromise(url, header, \"POST\", query);\n}\n\nexport function fetchJSONPromise(url: string, otherHeaders = new Map()): Promise<JSONValue> {\n    let header = new Map();\n    header.set('Content-Type', 'application/json');\n    otherHeaders.forEach((value, key) => {\n        header.set(key, value)\n    })\n    return fetchPromise(url, header).then(response => {\n        if(response == null || response == undefined || response == \"\") {\n            return {};\n        } else {\n            try {\n                return JSON.parse(response);\n            } catch (error) {\n                Logger.error(url, error, response)\n                throw error\n            }\n        }\n    });\n}\n\n/**\n * Taken from https://stackoverflow.com/questions/17267329/converting-unicode-character-to-string-format\n * @param text \n * @returns a string with unicode codes replaced by characters\n */\nexport function unicodeToUrlendcode(text: string): string {\n    return text.replace(/\\\\u[\\dA-F]{4}/gi,\n        function (match) {\n            let unicodeMatch = String.fromCharCode(parseInt(match.replace(/\\\\u/g, ''), 16));\n            let urlEncodedMatch = encodeURIComponent(unicodeMatch);\n            return urlEncodedMatch;\n        });\n}\n\n// Set the precision of a float\nexport function precise(x: number, n = 2): string {\n    return x.toPrecision(n);\n}","import dayjs from \"dayjs\"\nimport * as util from \"node:util\"\nimport { appendToFile, writeFile } from \"./GlobalUtils\";\n\nlet logFileName = \"kartographicaching.log\"\n\nexport function setLogFileName(fileName: string) {\n    if(fileName == null || fileName == undefined || fileName == \"\") {\n        logFileName = \"kartographicaching.log\";\n    } else {\n        logFileName = fileName;\n    }\n}\n\nexport function log(logObject: any, ...o: any[]) : void {\n    logging(\"LOG\", logObject, ...o);\n}\n\nexport function error(logObject: any, ...o: any[]) : void {\n    logging(\"ERROR\", logObject, ...o);\n}\n\nexport function info(logObject: any, ...o: any[]) : void {\n    logging(\"INFO\", logObject, ...o);\n}\n\nfunction logging(level, logObject: any, ...o: any[]): void {\n    const now = dayjs();\n    const message = util.format(\"[%s][%s]: %s\", level, now.toISOString(), logObject, ...o);\n    console.error(message);\n    appendToFile(logFileName, message + \"\\n\");\n}","import { fetchGETPromise, fetchJSONPromise, fetchPOSTPromise } from \"./GlobalUtils\";\nimport * as RDFUtils from \"./RDFUtils\";\nimport sparqljs from \"sparqljs\";\nimport * as $rdf from \"rdflib\";\nimport * as Logger from \"./LogUtils\"\nimport { JSONValue, SPARQLJSONResult } from \"./DataTypes\";\n\nexport let defaultQueryTimeout = 60000;\n\nexport const queryPaginationSize = 500;\n\nexport function setDefaultQueryTimeout(timeout: number) {\n    if (timeout != undefined && timeout != null && timeout >= 0) {\n        defaultQueryTimeout = timeout;\n    } else {\n        throw new Error(\"Timeout must be a positive number\")\n    }\n}\n\nexport function sparqlQueryPromise(endpoint, query, timeout: number = defaultQueryTimeout): Promise<$rdf.Formula | SPARQLJSONResult> {\n    let jsonHeaders = new Map();\n    jsonHeaders.set(\"Accept\", \"application/sparql-results+json\")\n    if (isSparqlSelect(query)) {\n        return fetchJSONPromise(endpoint + '?query=' + encodeURIComponent(query) + '&format=json&timeout=' + timeout, jsonHeaders).catch(error => { Logger.error(endpoint, query, error); throw error }) as Promise<SPARQLJSONResult>\n    } else if (isSparqlAsk(query)) {\n        return fetchJSONPromise(endpoint + '?query=' + encodeURIComponent(query) + '&format=json&timeout=' + timeout, jsonHeaders).catch(() => { return { boolean: false } }) as Promise<SPARQLJSONResult>\n    } else if (isSparqlConstruct(query)) {\n        return fetchGETPromise(endpoint + '?query=' + encodeURIComponent(query) + '&format=turtle&timeout=' + timeout)\n            .then(result => {\n                result = result.replaceAll(\"nodeID://\", \"_:\") // Dirty hack to fix nodeID:// from Virtuoso servers for turtle\n                console.log(result)\n                return RDFUtils.parseTurtleToStore(result, RDFUtils.createStore()).catch(error => {\n                    Logger.error(endpoint, query, error, result);\n                    throw error;\n                });\n            }).catch(error => { Logger.error(endpoint, query, error); throw error })\n    } else {\n        Logger.error(new Error(\"Unexpected query type\"))\n    }\n}\n\nexport function sendUpdateQuery(endpoint, updateQuery) {\n    let updateHeader = new Map();\n    updateHeader.set('Content-Type', 'application/sparql-update');\n    return fetchPOSTPromise(endpoint, updateQuery, updateHeader).then(response => {\n        return response;\n    }).catch(error => {\n        Logger.error(\"Error send update query\", error);\n    })\n}\n\nexport function checkSparqlType(queryString: string, queryType: \"CONSTRUCT\" | \"SELECT\" | \"ASK\" | \"DESCRIBE\" | \"update\") {\n    let parser = new sparqljs.Parser();\n    try {\n        const parsedQuery = parser.parse(queryString);\n        if (parsedQuery.queryType != undefined) {\n            return (parsedQuery.queryType.localeCompare(queryType) == 0);\n        } else if (parsedQuery.type != undefined) {\n            return (parsedQuery.type.localeCompare(queryType) == 0);\n        } else {\n            throw new Error(\"No expected query type property : \" + JSON.stringify(parsedQuery));\n        }\n    } catch (error) {\n        Logger.error(queryString, error)\n    }\n}\n\nexport function isSparqlConstruct(queryString: string): boolean {\n    return checkSparqlType(queryString, \"CONSTRUCT\");\n}\n\nexport function isSparqlSelect(queryString: string): boolean {\n    return checkSparqlType(queryString, \"SELECT\");\n}\n\nexport function isSparqlAsk(queryString: string): boolean {\n    return checkSparqlType(queryString, \"ASK\");\n}\n\nexport function isSparqlDescribe(queryString: string): boolean {\n    return checkSparqlType(queryString, \"DESCRIBE\");\n}\n\nexport function isSparqlUpdate(queryString: string): boolean {\n    return checkSparqlType(queryString, \"update\");\n}\n\nexport function sparqlQueryToIndeGxPromise(query: string, timeout: number = defaultQueryTimeout): Promise<$rdf.Formula | SPARQLJSONResult> {\n    return sparqlQueryPromise(\"http://prod-dekalog.inria.fr/sparql\", query, timeout);\n}\n\n\nfunction paginatedSparqlQueryPromise(endpointUrl: string, query: string, pageSize: number, iteration?: number, timeout?: number, finalResult?: $rdf.Formula | Array<JSONValue>): Promise<$rdf.Formula | Array<JSONValue>> {\n    let generator = new sparqljs.Generator();\n    let parser = new sparqljs.Parser();\n    if (iteration == undefined) {\n        iteration = 0;\n    }\n    if (timeout == undefined) {\n        timeout = defaultQueryTimeout;\n    }\n    let queryObject = parser.parse(query);\n    if (isSparqlSelect(query)) {\n        if (finalResult == undefined) {\n            finalResult = [] as Array<JSONValue>;\n        }\n    } else if (isSparqlConstruct(query)) {\n        if (finalResult == undefined) {\n            finalResult = RDFUtils.createStore() as $rdf.Formula;\n        }\n    }\n\n    // We add the OFFSET and LIMIT to the query\n    queryObject.offset = iteration * pageSize;\n    queryObject.limit = pageSize;\n\n    let generatedQuery = generator.stringify(queryObject);\n\n    // We send the paginated CONSTRUCT query\n    return sparqlQueryPromise(endpointUrl, generatedQuery, timeout).then(generatedQueryResult => {\n        if (generatedQueryResult !== undefined) {\n            if (isSparqlSelect(query)) {\n                try {\n                let parsedSelectQueryResult: JSONValue = generatedQueryResult as JSONValue;\n                (finalResult as Array<JSONValue>) = (finalResult as Array<JSONValue>).concat(parsedSelectQueryResult[\"results\"].bindings as JSONValue[]);\n                if ((parsedSelectQueryResult as JSONValue)[\"results\"].bindings.length > 0) {\n                    return paginatedSparqlQueryPromise(endpointUrl, query, pageSize, iteration + 1, timeout, finalResult);\n                } else {\n                    return finalResult;\n                }\n                    \n            } catch (error) {\n                Logger.error(\"Error while parsing the query result as SELECT result: \", error, generatedQueryResult);\n                throw error;\n            }\n            } else if (isSparqlConstruct(query)) {\n                (finalResult as $rdf.Formula).addAll((generatedQueryResult as $rdf.Formula).statements)\n                if ((generatedQueryResult as $rdf.Formula).statements.length > 0) {\n                    return paginatedSparqlQueryPromise(endpointUrl, query, pageSize, iteration + 1, timeout, finalResult);\n                } else {\n                    return finalResult;\n                }\n            } else {\n                return finalResult;\n            }\n        } else {\n            return finalResult;\n        }\n    }).catch(error => {\n        Logger.error(\"Error while paginating the query: \", error);\n        throw error;\n    })\n        .finally(() => {\n            return finalResult;\n        });\n}\n\nexport function paginatedSparqlQueryToIndeGxPromise(query, pageSize = 100): Promise<$rdf.Formula | Array<JSONValue>> {\n    return paginatedSparqlQueryPromise(\"http://prod-dekalog.inria.fr/sparql\", query, pageSize);\n}","import * as $rdf from \"rdflib\";\nimport * as fs from \"fs\";\nimport * as Global from \"./GlobalUtils\";\nimport * as Logger from \"./LogUtils\"\nimport ttl_read from \"@graphy/content.ttl.read\";\nimport nt_read from \"@graphy/content.nt.read\";\nimport nq_read from \"@graphy/content.nq.read\";\nimport trig_read from \"@graphy/content.trig.read\";\n\nexport const VOID = $rdf.Namespace(\"http://rdfs.org/ns/void#\");\nexport const XSD = $rdf.Namespace(\"http://www.w3.org/2001/XMLSchema#\");\nexport const DCAT = $rdf.Namespace(\"http://www.w3.org/ns/dcat#\");\nexport const PROV = $rdf.Namespace(\"http://www.w3.org/ns/prov#\");\nexport const SD = $rdf.Namespace(\"http://www.w3.org/ns/sparql-service-description#\");\nexport const DCT = $rdf.Namespace(\"http://purl.org/dc/terms/\");\nexport const PAV = $rdf.Namespace(\"http://purl.org/pav/\");\nexport const RDF = $rdf.Namespace(\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\");\nexport const RDFS = $rdf.Namespace(\"http://www.w3.org/2000/01/rdf-schema#\");\nexport const OWL = $rdf.Namespace(\"http://www.w3.org/2002/07/owl#\");\nexport const FOAF = $rdf.Namespace(\"http://xmlns.com/foaf/0.1/\");\nexport const SCHEMA = $rdf.Namespace(\"http://schema.org/\");\nexport const DCE = $rdf.Namespace(\"http://purl.org/dc/elements/1.1/\");\nexport const SKOS = $rdf.Namespace(\"http://www.w3.org/2004/02/skos/core#\");\nexport const MOD = $rdf.Namespace(\"https://w3id.org/mod#\");\nexport const EARL = $rdf.Namespace(\"http://www.w3.org/ns/earl#\");\nexport const MANIFEST = $rdf.Namespace(\"http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#\");\nexport const KGI = $rdf.Namespace(\"http://ns.inria.fr/kg/index#\");\n\nexport const rdfTypeProperty = RDF(\"type\");\n\nexport function urlToBaseURI(url: string): string {\n    const baseURI = url.replace(new RegExp(\"/^(?:.*\\/)*([^\\/\\r\\n]+?|)(?=(?:\\.[^\\/\\r\\n.\\.]*\\.)?$)/gm\"), \"\");\n    return baseURI;\n}\n\n\nexport function createStore(): $rdf.Store {\n    let store = $rdf.graph();\n    store.setPrefixForURI(\"cc\", \"http://creativecommons.org/ns#\");\n    store.setPrefixForURI(\"culturefr\", \"https://www.culture.gouv.fr/\");\n    store.setPrefixForURI(\"dbfr\", \"http://fr.dbpedia.org/\");\n    store.setPrefixForURI(\"dbfrg\", \"http://fr.dbpedia.org/graph/\");\n    store.setPrefixForURI(\"dbfrp\", \"http://fr.dbpedia.org/property/\");\n    store.setPrefixForURI(\"dbo\", \"http://dbpedia.org/ontology/\");\n    store.setPrefixForURI(\"dbspr\", \"http://dbpedia.org/schema/property_rules#\");\n    store.setPrefixForURI(\"dcat\", \"http://www.w3.org/ns/dcat#\");\n    store.setPrefixForURI(\"dce\", \"http://purl.org/dc/elements/1.1/\");\n    store.setPrefixForURI(\"dcmitype\", \"http://purl.org/dc/dcmitype/\");\n    store.setPrefixForURI(\"eclass\", \"http://www.ebusiness-unibw.org/ontologies/eclass/5.1.4/#\");\n    store.setPrefixForURI(\"ex\", \"https://e.g/#\");\n    store.setPrefixForURI(\"georss\", \"http://www.georss.org/georss/\");\n    store.setPrefixForURI(\"goodrel\", \"http://purl.org/goodrelations/v1#\");\n    store.setPrefixForURI(\"inria\", \"https://www.inria.fr/\");\n    store.setPrefixForURI(\"kgi\", \"http://ns.inria.fr/kg/index#\");\n    store.setPrefixForURI(\"localdav\", \"http://localhost:8890/DAV/\");\n    store.setPrefixForURI(\"mod\", \"https://w3id.org/mod#\");\n    store.setPrefixForURI(\"oa\", \"http://www.w3.org/ns/oa#\");\n    store.setPrefixForURI(\"openvoc\", \"http://open.vocab.org/terms/\");\n    store.setPrefixForURI(\"pav\", \"http://purl.org/pav/\");\n    store.setPrefixForURI(\"powders\", \"http://www.w3.org/2007/05/powder-s#\");\n    store.setPrefixForURI(\"schema\", \"http://schema.org/\");\n    store.setPrefixForURI(\"sd\", \"http://www.w3.org/ns/sparql-service-description#\");\n    store.setPrefixForURI(\"skos\", \"http://www.w3.org/2004/02/skos/core#\");\n    store.setPrefixForURI(\"vann\", \"http://purl.org/vocab/vann/\");\n    store.setPrefixForURI(\"voaf\", \"http://purl.org/vocommons/voaf#\");\n    store.setPrefixForURI(\"wdentity\", \"http://www.wikidata.org/entity/\");\n    store.setPrefixForURI(\"wimmics\", \"https://team.inria.fr/wimmics/\");\n    return store;\n}\n\nfunction getGraphyReadingFunction(contentType: FileContentType) {\n    switch (contentType) {\n        case NQuadsContentType:\n            return nq_read;\n        case NTriplesContentType:\n            return nt_read;\n        case TrigContentType:\n            return trig_read;\n        default:\n        case TurtleContentType:\n            return ttl_read;\n    }\n}\n\nfunction graphyQuadLoadingToStore(store: $rdf.Store, y_quad: any, baseURI = KGI(\"\").value): void {\n    let s = undefined;\n    if (y_quad.subject.termType === \"NamedNode\") { \n        s = $rdf.sym(y_quad.subject.value) \n    } else if (y_quad.subject.termType === \"Literal\" )  { \n        if(y_quad.subject.language != null && y_quad.subject.language != undefined && y_quad.subject.language != \"\") {\n            s = $rdf.lit(y_quad.subject.value, y_quad.subject.language)\n        } else if(y_quad.subject.datatype != null && y_quad.subject.datatype != undefined && y_quad.subject.datatype != \"\") {\n            s = $rdf.lit(y_quad.subject.value, undefined, $rdf.sym(y_quad.subject.datatype))\n        } else {\n            s = $rdf.lit(y_quad.subject.value)\n        }\n    } else { \n        s = $rdf.blankNode(baseURI + \"#\" + y_quad.subject.value)\n    };\n    const p = $rdf.sym(y_quad.predicate.value);\n    let o = undefined;\n    if (y_quad.object.termType === \"NamedNode\") { \n        o = $rdf.sym(y_quad.object.value) \n    } else if (y_quad.object.termType === \"Literal\") { \n        if(y_quad.object.language != null && y_quad.object.language != undefined && y_quad.object.language != \"\") {\n            o = $rdf.lit(y_quad.object.value, y_quad.object.language)\n        } else if(y_quad.object.datatype != null && y_quad.object.datatype != undefined && y_quad.object.datatype != \"\") {\n            o = $rdf.lit(y_quad.object.value, undefined, $rdf.sym(y_quad.object.datatype))\n        } else {\n            o = $rdf.lit(y_quad.object.value)\n        }\n    } else { \n        o = $rdf.blankNode(baseURI + \"#\" + y_quad.object.value) \n    };\n\n    if (!$rdf.isLiteral(s)) { // The application of RDF reasoning makes appear Literals as subjects, for some reason. We filter them out.\n        if (y_quad.graph.value === '') {\n            store.add(s, p, o);\n        } else {\n            const g = $rdf.sym(y_quad.graph);\n            store.add(s, p, o, g);\n        }\n    }\n}\n\nexport function loadRDFFile(file: string, store: $rdf.Store, baseURI?: string): Promise<void> {\n    return loadRDFFiles([file], store, baseURI);\n}\n\nexport function loadRDFFiles(files: Array<string>, store: $rdf.Store, generalBaseUri?: string): Promise<void> {\n    try {\n        const promiseArray = files.map(filename => {\n            let baseURI = urlToBaseURI(filename);\n            if (generalBaseUri != null && generalBaseUri != undefined) {\n                baseURI = generalBaseUri;\n            }\n            const contentType = guessContentType(filename);\n            let readingFunction = ttl_read;\n            if (contentType != undefined) {\n                readingFunction = getGraphyReadingFunction(contentType)\n            } else {\n                throw new Error(\"Unsupported content type for \" + filename + \", only .ttl, .nq, .nt and .trig supported.\");\n            }\n\n            return new Promise<void>((resolve, reject) => {\n                try {\n                    if (filename.startsWith(\"http\")) {\n                        filename = filename.replace(\"http://\", \"https://\");\n                    } else if (filename.startsWith(\"file\")) {\n                        filename = filename.replace(\"file://\", \"\");\n                    }\n                    fs.createReadStream(filename)\n                        .pipe(readingFunction({ baseURI: baseURI }))\n                        .on('data', (y_quad) => {\n                            graphyQuadLoadingToStore(store, y_quad, baseURI)\n                        })\n                        .on('eof', prefixes => {\n                            resolve();\n                        })\n                        .on('error', (error) => {\n                            Logger.error(\"Error while reading RDF file\", filename, \"during stream\", \"error\", error);\n                            reject(error)\n                        });\n                } catch (error) {\n                    Logger.error(\"Error while loading RDF files\", files, \"error\", error);\n                    reject(error)\n                }\n            }).catch(error => {\n                Logger.error(\"Error while loading RDF files\", files, \"error\", error);\n                return Promise.reject(error);\n            })\n        });\n        return Promise.allSettled(promiseArray).then(() => { });\n    } catch (error) {\n        Logger.error(\"Error while loading RDF files\", files, \"error\", error);\n        return Promise.reject(error);\n    }\n}\n\nexport function serializeStoreToTurtlePromise(store: $rdf.Store): Promise<string> {\n    return new Promise((accept, reject) => {\n        try {\n            $rdf.serialize(null, store, KGI(\"\").value, 'text/turtle', function (err, str) {\n                if (err != null) {\n                    reject(err);\n                }\n                str = Global.unicodeToUrlendcode(str)\n                accept(str)\n            }, { namespaces: store.namespaces });\n        } catch (error) {\n            reject(error);\n        }\n    })\n}\n\nexport function serializeStoreToNTriplesPromise(store: $rdf.Store): Promise<string> {\n    return new Promise((accept, reject) => {\n        try {\n            $rdf.serialize(null, store, KGI(\"\").value, 'application/n-triples', function (err, str) {\n                if (err != null) {\n                    reject(err);\n                }\n                str = Global.unicodeToUrlendcode(str)\n                accept(str)\n            }, {\n                // flags: 'deinprstux', // r: Flag to escape /u unicode characters, t: flag to replace rdf:type by \"a\", d: flag to use the default namespace for unqualified terms with prefix \":\"\n                namespaces: store.namespaces\n            });\n        } catch (error) {\n            reject(error);\n        }\n    })\n}\n\nexport function serializeStoreToTriGPromise(store: $rdf.Store): Promise<string> {\n    return new Promise((accept, reject) => {\n        try {\n            $rdf.serialize(null, store, KGI(\"\").value, 'application/trig', function (err, str) {\n                if (err != null) {\n                    reject(err);\n                }\n                str = Global.unicodeToUrlendcode(str)\n                accept(str)\n            }, { namespaces: store.namespaces });\n        } catch (error) {\n            reject(error);\n        }\n    })\n}\n\nexport function serializeStoreToQuadsPromise(store: $rdf.Store): Promise<string> {\n    return new Promise((accept, reject) => {\n        try {\n            $rdf.serialize(null, store, KGI(\"\").value, 'application/nquads', function (err, str) {\n                if (err != null) {\n                    reject(err);\n                }\n                str = Global.unicodeToUrlendcode(str)\n                accept(str)\n            }, { namespaces: store.namespaces });\n        } catch (error) {\n            reject(error);\n        }\n    })\n}\n\nexport function parseNTriplesToStore(content: string, store: $rdf.Store): Promise<$rdf.Formula> {\n    return new Promise((accept, reject) => {\n        try {\n            content = Global.unicodeToUrlendcode(content)\n            $rdf.parse(content, store, KGI(\"\").value, \"application/n-triples\", (err, kb) => {\n                if (err != null) {\n                    reject(err);\n                }\n                accept(kb);\n            })\n        } catch (error) {\n            reject(error);\n        }\n    });\n}\n\nexport function parseN3ToStore(content: string, store: $rdf.Store): Promise<$rdf.Formula> {\n    return new Promise((accept, reject) => {\n        try {\n            content = Global.unicodeToUrlendcode(content)\n            $rdf.parse(content, store, KGI(\"\").value, \"text/n3\", (err, kb) => {\n                if (err != null) {\n                    reject(err);\n                }\n                accept(kb);\n            })\n        } catch (error) {\n            reject(error);\n        }\n    });\n}\n\nexport function parseTurtleToStore(content: string, store: $rdf.Store, baseURI = KGI(\"\").value): Promise<$rdf.Formula> {\n    return new Promise((accept, reject) => {\n        try {\n            ttl_read(content, {\n                data(y_quad) {\n                    graphyQuadLoadingToStore(store, y_quad, baseURI)\n                },\n                eof( prefixes) {\n                    accept(store);\n                },\n                error(error) {\n                    Logger.error(\"Error while parsing turtle content\", \"error\", error);\n                    reject(error)\n                }\n            })\n        } catch (error) {\n            reject(error);\n        }\n    });\n}\n\nexport function parseHTMLToStore(content: string, store: $rdf.Store): Promise<$rdf.Formula> {\n    return new Promise((accept, reject) => {\n        try {\n            content = Global.unicodeToUrlendcode(content)\n            $rdf.parse(content, store, KGI(\"\").value, \"text/html\", (err, kb) => {\n                if (err != null) {\n                    reject(err);\n                }\n                accept(kb);\n            })\n        } catch (error) {\n            reject(error);\n        }\n    });\n}\n\nexport function parseJSONLDToStore(content: string, store: $rdf.Store): Promise<$rdf.Formula> {\n    return new Promise((accept, reject) => {\n        try {\n            content = Global.unicodeToUrlendcode(content)\n            $rdf.parse(content, store, KGI(\"\").value, \"application/ld+json\", (err, kb) => {\n                if (err != null) {\n                    reject(err);\n                }\n                accept(kb);\n            })\n        } catch (error) {\n            reject(error);\n        }\n    });\n}\n\nexport function parseNQuadsToStore(content: string, store: $rdf.Store): Promise<$rdf.Formula> {\n    return new Promise((accept, reject) => {\n        try {\n            content = Global.unicodeToUrlendcode(content)\n            $rdf.parse(content, store, KGI(\"\").value, \"application/nquads\", (err, kb) => {\n                if (err != null) {\n                    reject(err);\n                }\n                accept(kb);\n            })\n        } catch (error) {\n            reject(error);\n        }\n    });\n}\n\nexport function parseRDFXMLToStore(content: string, store: $rdf.Store): Promise<$rdf.Formula> {\n    return new Promise((accept, reject) => {\n        try {\n            content = Global.unicodeToUrlendcode(content)\n            $rdf.parse(content, store, KGI(\"\").value, \"application/rdf+xml\", (err, kb) => {\n                if (err != null) {\n                    reject(err);\n                }\n                accept(kb);\n            })\n        } catch (error) {\n            reject(error);\n        }\n    });\n}\n\nexport function queryRDFLibStore(store: $rdf.Store, query: string) {\n    return new Promise((resolve, reject) => {\n        try {\n            let parsedQuery = $rdf.SPARQLToQuery(query, false, store);\n            if (parsedQuery as $rdf.Query) {\n                parsedQuery = parsedQuery as $rdf.Query;\n                store.query(parsedQuery, results => {\n                    resolve(results);\n                });\n            } else {\n                reject(\"Query is not a valid SPARQL query\" + query);\n            }\n        } catch (error) {\n            reject(error);\n        }\n    });\n}\n\n/**\n    Converts an RDF collection represented by the given named node, blank node, or variable into an array of nodes.\n    @param {$rdf.NamedNode | $rdf.BlankNode | $rdf.Variable} collection - The node representing the collection to convert.\n    @param {$rdf.Store} store - The RDF store containing the collection.\n    @returns {$rdf.Node[]} An array of nodes representing the collection.\n    */\nexport function collectionToArray(collection: $rdf.NamedNode | $rdf.BlankNode | $rdf.Variable, store: $rdf.Store): $rdf.Node[] {\n    let result = [];\n\n    store.statementsMatching(collection, RDF(\"first\")).forEach(statement => {\n        if (!statement.object.equals(RDF(\"nil\"))) {\n            result.push(statement.object);\n        }\n    });\n\n    store.statementsMatching(collection, RDF(\"rest\")).forEach(statement => {\n        if (!statement.object.equals(RDF(\"nil\"))) {\n            if ($rdf.isNamedNode(statement.object)) {\n                result = result.concat(collectionToArray(statement.object as $rdf.NamedNode, store));\n            } else if ($rdf.isBlankNode(statement.object)) {\n                result = result.concat(collectionToArray(statement.object as $rdf.BlankNode, store));\n            }\n        }\n    });\n\n    return [...new Set(result)];\n}\n\nexport const NTriplesContentType = \"application/n-triples\" as const\nexport const NQuadsContentType = \"application/nquads\" as const\nexport const TurtleContentType = \"text/turtle\" as const\nexport const TrigContentType = \"application/trig\" as const\n\nexport type FileContentType = typeof TurtleContentType | typeof NTriplesContentType | typeof NQuadsContentType | typeof TrigContentType;\n\nexport function guessContentType(filename: string): FileContentType | undefined {\n    filename = filename.trim();\n    if (filename.endsWith(\".ttl\")) {\n        return TurtleContentType;\n    } else if (filename.endsWith(\".nt\")) {\n        return NTriplesContentType;\n    } else if (filename.endsWith(\".nq\")) {\n        return NQuadsContentType;\n    } else if (filename.endsWith(\".trig\")) {\n        return TrigContentType;\n    } else {\n        return undefined;\n    }\n}","import * as echarts from \"echarts\";\nimport * as DataCache from \"./DataCaching\";\nimport { readFile, writeFile } from \"fs/promises\";\nimport { AverageRuntimeDataObject, ClassCountDataObject, DatasetDescriptionDataObject, EndpointTestDataObject, GeolocDataObject, GraphListDataObject, KeywordsEndpointDataObject, PropertyCountDataObject, QualityMeasureDataObject, ShortUriDataObject, SPARQLCoverageDataObject, SPARQLFeatureDataObject, SPARQLFeatureDescriptionDataObject, TotalRuntimeDataObject, TripleCountDataObject, VocabEndpointDataObject, VocabKeywordsDataObject } from \"./DataTypes\";\nimport * as Logger from \"./LogUtils\";\nimport * as ChartsUtils from \"./ChartsUtils\";\nimport * as Global from \"./GlobalUtils\";\nimport dayjs from \"dayjs\";\n\nconst numberOfVocabulariesLimit = 1000;\n\nexport const sparqlCoverageEchartsOptionFilename = \"sparqlCoverageEchartsOption\";\nexport const sparql10CoverageEchartsOptionFilename = \"sparql10CoverageEchartsOption\";\nexport const sparql11CoverageEchartsOptionFilename = \"sparql11CoverageEchartsOption\";\nexport const vocabEndpointEchartsOptionFilename = \"vocabEndpointEchartsOption\";\nexport const triplesEchartOptionFilename = \"triplesEchartOption\";\nexport const classesEchartOptionFilename = \"classesEchartOption\";\nexport const propertiesEchartOptionFilename = \"propertiesEchartOption\";\nexport const shortUrisEchartOptionFilename = \"shortUrisEchartOption\";\nexport const rdfDataStructuresEchartOptionFilename = \"rdfDataStructuresEchartOption\";\nexport const readableLabelsEchartOptionFilename = \"readableLabelsEchartOption\";\nexport const blankNodesEchartOptionFilename = \"blankNodesEchartOption\";\nexport const datasetDescriptionEchartOptionFilename = \"datasetDescriptionEchartOption\";\nexport const totalRuntimeEchartsOptionFilename = \"totalRuntimeEchartsOption\";\nexport const keywordEndpointEchartsOptionFilename = \"keywordEndpointEchartsOption\";\nexport const standardVocabulariesEndpointGraphEchartsOptionFilename = \"standardVocabulariesEndpointGraphEchartsOption\";\n\n\nlet whiteListData: Map<string, Array<string>>;\nlet geolocData: Array<GeolocDataObject>;\nlet sparqlFeaturesData: Array<SPARQLFeatureDataObject>;\nlet knownVocabData: Array<string>;\nlet vocabKeywordData: Array<VocabKeywordsDataObject>;\nlet classCountData: Array<ClassCountDataObject>;\nlet propertyCountData: Array<PropertyCountDataObject>;\nlet tripleCountData: Array<TripleCountDataObject>;\nlet shortUrisData: Array<ShortUriDataObject>;\nlet rdfDataStructureData: Array<QualityMeasureDataObject>;\nlet readableLabelData: Array<QualityMeasureDataObject>;\nlet blankNodesData: Array<QualityMeasureDataObject>;\nlet classPropertyData: any;\nlet datasetDescriptionData: Array<DatasetDescriptionDataObject>;\nlet sparqlFeatureDesc: Array<SPARQLFeatureDescriptionDataObject>;\n\nexport function sparqlCoverageEchartsOption(runsetId: string): Promise<void> {\n    return readFile(Global.getCachedFilenameForRunset(runsetId, DataCache.sparqlCoverageFilename), \"utf8\").then(sparqlCoverageCountRawData => {\n\n        const sparqlCoverageCountData: Array<SPARQLCoverageDataObject> = JSON.parse(sparqlCoverageCountRawData);\n\n        let maxSparql10 = 25;\n        let maxSparql11 = 19;\n        let maxSparqlTotal = maxSparql10 + maxSparql11;\n\n        let chart10ValueMap = new Map();\n        let chart11ValueMap = new Map();\n        let chartSPARQLValueMap = new Map();\n\n        for (let i = -1; i < 10; i++) {\n            chart10ValueMap.set(i, 0);\n            chart11ValueMap.set(i, 0);\n            chartSPARQLValueMap.set(i, 0);\n        }\n        let sparql10Step = maxSparql10 / 10;\n        let sparql11Step = maxSparql11 / 10;\n        let sparqlTotalStep = maxSparqlTotal / 10;\n        sparqlCoverageCountData.forEach((item) => {\n            let itemBinSparql10 = -1;\n            if (item.sparql10 > 0) {\n                itemBinSparql10 = Math.floor(item.sparql10 / sparql10Step);\n                if (itemBinSparql10 == 10) {\n                    itemBinSparql10 = 9;\n                }\n            }\n            chart10ValueMap.set(itemBinSparql10, chart10ValueMap.get(itemBinSparql10) + 1);\n            let itemBinSparql11 = -1;\n            if (item.sparql11 > 0) {\n                itemBinSparql11 = Math.floor(item.sparql11 / sparql11Step);\n                if (itemBinSparql11 == 10) {\n                    itemBinSparql11 = 9;\n                }\n            }\n            chart11ValueMap.set(itemBinSparql11, chart11ValueMap.get(itemBinSparql11) + 1);\n            let itemBinSparqlTotal = -1;\n            if (item.sparql11 > 0 || item.sparql10 > 0) {\n                itemBinSparqlTotal = Math.floor(item.sparqlTotal / sparqlTotalStep);\n                if (itemBinSparqlTotal == 10) {\n                    itemBinSparqlTotal = 9;\n                }\n            }\n            chartSPARQLValueMap.set(itemBinSparqlTotal, chartSPARQLValueMap.get(itemBinSparqlTotal) + 1);\n        });\n\n        let chart10DataMap = new Map();\n        let chart11DataMap = new Map();\n        let chartSPARQLDataMap = new Map();\n        let categorySet = new Set<string>();\n        chart10ValueMap.forEach((binCount, itemBin, map) => {\n            let categoryName = \"[ \" + ((itemBin) * 10).toString() + \"%, \" + ((itemBin + 1) * 10).toString() + \" % ]\";\n            if (itemBin == 0) {\n                categoryName = \"] \" + ((itemBin) * 10).toString() + \"%, \" + ((itemBin + 1) * 10).toString() + \" % ]\";\n            }\n            if (itemBin == -1) {\n                categoryName = \"[ 0% ]\";\n            }\n            categorySet.add(categoryName);\n            chart10DataMap.set(categoryName, binCount);\n        });\n        chart11ValueMap.forEach((binCount, itemBin, map) => {\n            let categoryName = \"[ \" + ((itemBin) * 10).toString() + \"%, \" + ((itemBin + 1) * 10).toString() + \" % ]\";\n            if (itemBin == 0) {\n                categoryName = \"] \" + ((itemBin) * 10).toString() + \"%, \" + ((itemBin + 1) * 10).toString() + \" % ]\";\n            }\n            if (itemBin == -1) {\n                categoryName = \"[ 0% ]\";\n            }\n            categorySet.add(categoryName);\n            chart11DataMap.set(categoryName, binCount);\n        });\n        chartSPARQLValueMap.forEach((binCount, itemBin, map) => {\n            let categoryName = \"[ \" + ((itemBin) * 10).toString() + \"%, \" + ((itemBin + 1) * 10).toString() + \" % ]\";\n            if (itemBin == 0) {\n                categoryName = \"] \" + ((itemBin) * 10).toString() + \"%, \" + ((itemBin + 1) * 10).toString() + \" % ]\";\n            }\n            if (itemBin == -1) {\n                categoryName = \"[ 0% ]\";\n            }\n            categorySet.add(categoryName);\n            chartSPARQLDataMap.set(categoryName, binCount);\n        });\n        // let categories = ([...categorySet]).sort((a, b) => a.localeCompare(b));\n\n        let sparql10Series: any[] = [];\n        chart10DataMap.forEach((percentage, category, map) => {\n            sparql10Series.push({\n                name: category,\n                type: 'bar',\n                data: [percentage],\n                label: {\n                    show: true,\n                    formatter: \"{a}\",\n                    verticalAlign: \"bottom\",\n                    position: \"top\"\n                }\n            })\n        });\n        let sparql11Series: any[] = [];\n        chart11DataMap.forEach((percentage, category, map) => {\n            sparql11Series.push({\n                name: category,\n                type: 'bar',\n                data: [percentage],\n                label: {\n                    show: true,\n                    formatter: \"{a}\",\n                    verticalAlign: \"bottom\",\n                    position: \"top\"\n                }\n            })\n        });\n        let sparqlCategorySeries: any[] = [];\n        chartSPARQLDataMap.forEach((percentage, category, map) => {\n            sparqlCategorySeries.push({\n                name: category,\n                type: 'bar',\n                data: [percentage],\n                label: {\n                    show: true,\n                    formatter: \"{a}\",\n                    verticalAlign: \"bottom\",\n                    position: \"top\"\n                }\n            })\n        });\n\n        let sparql10ChartOption = {\n            title: {\n                left: 'center',\n                text: \"Number of endpoints according to\\n their coverage of SPARQL 1.0 features\",\n                textStyle: {\n                    overflow: 'breakAll',\n                    width: \"80%\"\n                }\n            },\n            legend: {\n                show: false,\n            },\n            toolbox: {\n                show: false\n            },\n            tooltip: {\n                show: true\n            },\n            xAxis: {\n                type: 'category',\n                data: [\"Endpoints supporting SPARQL 1.0 features\"],\n                show: false,\n                splitLine: { show: false },\n                splitArea: { show: false }\n            },\n            yAxis: {\n                type: 'value',\n                max: 'dataMax',\n            },\n            color: [\"#060705ff\", \"#10200Eff\", \"#1A3917ff\", \"#245121ff\", \"#2E6A2Aff\", \"#388333ff\", \"#419C3Cff\", \"#4BB545ff\", \"#55CD4Fff\", \"#5FE658ff\", \"#69FF61ff\"],\n            series: sparql10Series,\n        };\n        let sparql11ChartOption = {\n            title: {\n                left: 'center',\n                text: \"Number of endpoints according to\\n their coverage of SPARQL 1.1 features\",\n                textStyle: {\n                    overflow: 'breakAll',\n                    width: \"80%\"\n                }\n            },\n            legend: {\n                show: false,\n            },\n            toolbox: {\n                show: false\n            },\n            tooltip: {\n                show: true\n            },\n            xAxis: {\n                type: 'category',\n                data: [\"Endpoints supporting SPARQL 1.1 features\"],\n                show: false,\n                splitLine: { show: false },\n                splitArea: { show: false }\n            },\n            yAxis: {\n                type: 'value',\n                max: 'dataMax',\n            },\n            color: [\"#060705ff\", \"#10200Eff\", \"#1A3917ff\", \"#245121ff\", \"#2E6A2Aff\", \"#388333ff\", \"#419C3Cff\", \"#4BB545ff\", \"#55CD4Fff\", \"#5FE658ff\", \"#69FF61ff\"],\n            series: sparql11Series,\n        };\n        let sparqlChartOption = {\n            title: {\n                left: 'center',\n                text: \"Number of endpoints according to\\n their coverage of all SPARQL features\",\n                textStyle: {\n                    overflow: 'breakAll',\n                    width: \"80%\"\n                }\n            },\n            legend: {\n                show: false,\n            },\n            toolbox: {\n                show: false\n            },\n            tooltip: {\n                show: true\n            },\n            xAxis: {\n                type: 'category',\n                data: [\"Endpoints supporting SPARQL 1.0 and 1.1 features\"],\n                splitLine: { show: false },\n                splitArea: { show: false },\n                show: false\n            },\n            yAxis: {\n                type: 'value',\n                max: 'dataMax',\n            },\n            color: [\"#060705ff\", \"#10200Eff\", \"#1A3917ff\", \"#245121ff\", \"#2E6A2Aff\", \"#388333ff\", \"#419C3Cff\", \"#4BB545ff\", \"#55CD4Fff\", \"#5FE658ff\", \"#69FF61ff\"],\n            series: sparqlCategorySeries,\n        };\n\n        return Promise.allSettled([\n            writeFile(Global.getCachedFilenameForRunset(runsetId, sparql10CoverageEchartsOptionFilename), JSON.stringify(sparql10ChartOption)).then(() => { Logger.info(\"SPARQL 1.0 chart data for\", runsetId, \" generated\"); }),\n            writeFile(Global.getCachedFilenameForRunset(runsetId, sparql11CoverageEchartsOptionFilename), JSON.stringify(sparql11ChartOption)).then(() => { Logger.info(\"SPARQL 1.1 chart data for\", runsetId, \" generated\"); }),\n            writeFile(Global.getCachedFilenameForRunset(runsetId, sparqlCoverageEchartsOptionFilename), JSON.stringify(sparqlChartOption)).then(() => { Logger.info(\"SPARQL chart data for\", runsetId, \" generated\"); })\n        ]).then(() => {\n            return Promise.resolve();\n        });\n    }).catch((error) => {\n        Logger.error(\"Error during sparql cached data reading\", error)\n    });\n}\n\nexport function endpointVocabsGraphEchartsOption(runsetId: string): Promise<void> {\n    return readFile(Global.getCachedFilenameForRunset(runsetId, DataCache.vocabEndpointFilename), \"utf-8\").then(vocabEndpointRawData => {\n\n        let vocabEndpointData: Array<VocabEndpointDataObject> = JSON.parse(vocabEndpointRawData);\n        // Create an force graph with the graph linked by co-ocurrence of vocabularies\n\n        // Endpoint and vocabularies graph\n        let linkArray = [];\n        let nodeArray = [];\n        let vocabularySet: Set<string> = new Set();\n        let endpointSet: Set<string> = new Set();\n        vocabEndpointData.forEach((item, i) => {\n            let endpoint = item.endpoint;\n            let vocabularies = item.vocabularies;\n            if (vocabularies !== undefined) {\n                endpointSet.add(endpoint);\n                vocabularies.forEach(vocab => {\n                    vocabularySet.add(vocab)\n\n                    linkArray.push({ source: endpoint, target: vocab })\n                })\n            }\n        });\n\n        endpointSet.forEach(endpoint => {\n            nodeArray.push({ name: endpoint, category: 'Endpoint', symbolSize: 5 })\n        })\n        vocabularySet.forEach(vocab => {\n            nodeArray.push({ name: vocab, category: 'Vocabulary', symbolSize: 5 })\n        })\n\n        if (nodeArray.length > 0 && linkArray.length > 0) {\n            let content = JSON.stringify(ChartsUtils.getForceGraphOption('Endpoints and vocabularies*', [\"Vocabulary\", \"Endpoint\"], nodeArray, linkArray));\n            return writeFile(Global.getCachedFilenameForRunset(runsetId, vocabEndpointEchartsOptionFilename), content);\n        } else {\n            return Promise.reject(\"No data to generate the vocabulary graph for \" + runsetId);\n        }\n    }).catch((error) => {\n        Logger.error(\"Error during vocab graph data reading\", error)\n    });\n}\n\nexport function endpointKeywordsGraphEchartsOption(runsetId: string): Promise<void> {\n    return readFile(Global.getCachedFilenameForRunset(runsetId, DataCache.endpointKeywordsFilename), \"utf-8\").then(endpointKeywordsRawData => {\n\n        \n        let endpointKeywordData: Array<KeywordsEndpointDataObject> = JSON.parse(endpointKeywordsRawData);\n        // Endpoint and keywords graph\n        let linkArray = [];\n        let nodeArray = [];\n        let keywordSet: Set<string> = new Set();\n        let endpointSet: Set<string> = new Set();\n        endpointKeywordData.forEach((item, i) => {\n            let endpoint = item.endpoint;\n            let keywords = item.keywords;\n            if (keywords !== undefined) {\n                endpointSet.add(endpoint);\n                keywords.forEach(vocab => {\n                    keywordSet.add(vocab)\n\n                    linkArray.push({ source: endpoint, target: vocab })\n                })\n            }\n        });\n\n        endpointSet.forEach(endpoint => {\n            nodeArray.push({ name: endpoint, category: 'Endpoint', symbolSize: 5 })\n        })\n        keywordSet.forEach(vocab => {\n            nodeArray.push({ name: vocab, category: 'Keyword', symbolSize: 5 })\n        })\n        if (nodeArray.length > 0 && linkArray.length > 0) {\n            let content = JSON.stringify(ChartsUtils.getForceGraphOption('Endpoints and keywords of their vocabularies', [\"Keyword\", \"Endpoint\"], nodeArray, linkArray));\n            return writeFile(Global.getCachedFilenameForRunset(runsetId, keywordEndpointEchartsOptionFilename), content);\n        } else {\n            return Promise.reject(\"No data to generate the keyword graph for \" + runsetId);\n        }\n    }).catch((error) => {\n        Logger.error(\"Error during keyword graph data reading\", error)\n    });\n}\n\nexport function endpointStandardVocabulariesGraphEchartsOption(runsetId: string): Promise<void> {\n    return readFile(Global.getCachedFilenameForRunset(runsetId, DataCache.vocabEndpointFilename), \"utf-8\").then(vocabEndpointRawData => {\n        let vocabEndpointData: Array<VocabEndpointDataObject> = JSON.parse(vocabEndpointRawData);\n\n        let vocabStandardSet: Set<string> = new Set();\n        let vocabStandardNameMap: Map<string, string> = new Map([[\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\", \"RDF\"], [\"http://www.w3.org/2000/01/rdf-schema#\", \"RDFS\"], [\"http://www.w3.org/ns/shacl#\", \"SHACL\"], [\"http://www.w3.org/2002/07/owl#\", \"OWL\"], [\"http://www.w3.org/2004/02/skos/core#\", \"SKOS\"], [\"http://spinrdf.org/spin#\", \"SPIN\"], [\"http://www.w3.org/2003/11/swrl#\", \"SWRL\"]]);\n        vocabStandardNameMap.forEach((value, key, map) => {\n            vocabStandardSet.add(key);\n        });\n        // Endpoint and vocabularies graph\n        let linkArray = [];\n        let nodeArray = [];\n        let vocabSet: Set<string> = new Set();\n        let endpointSet: Set<string> = new Set();\n        vocabEndpointData.forEach((item, i) => {\n            let endpoint = item.endpoint;\n            let vocabularies = item.vocabularies;\n            if (vocabularies !== undefined) {\n                endpointSet.add(endpoint);\n                vocabularies.forEach(vocab => {\n                    if (vocabStandardSet.has(vocab)) {\n                        vocabSet.add(vocab)\n\n                        linkArray.push({ source: vocab, target: endpoint })\n                    }\n                })\n            }\n        });\n\n        endpointSet.forEach(endpoint => {\n            nodeArray.push({ name: endpoint, category: 'Endpoint', symbolSize: 5 })\n        })\n        vocabSet.forEach(vocab => {\n            nodeArray.push({ name: vocab, category: vocabStandardNameMap.get(vocab), symbolSize: 5 })\n        })\n\n        if (nodeArray.length > 0 && linkArray.length > 0) {\n            let categoryArray = [...vocabStandardSet].map(vocab => vocabStandardNameMap.get(vocab));\n            categoryArray.push(\"Endpoint\")\n            let content = JSON.stringify(ChartsUtils.getCircularGraphOption('Endpoints and meta-vocabularies', categoryArray, nodeArray, linkArray));\n            return writeFile(Global.getCachedFilenameForRunset(runsetId, standardVocabulariesEndpointGraphEchartsOptionFilename), content);\n        } else {\n            return Promise.reject(\"No data to generate the vocabulary graph for \" + runsetId);\n        }\n    }).catch((error) => {\n        Logger.error(\"Error during vocab graph data reading\", error)\n    });\n}\n\nexport function triplesEchartsOption(runsetId: string): Promise<void> {\n    return readFile(Global.getCachedFilenameForRunset(runsetId, DataCache.tripleCountFilename), \"utf-8\").then(tripleCountRawData => {\n        tripleCountData = JSON.parse(tripleCountRawData);\n        // Scatter plot of the number of triples through time\n        let endpointDataSerieMap = new Map();\n        tripleCountData.forEach((itemResult, i) => {\n            let endpointUrl = itemResult.endpoint;\n            endpointDataSerieMap.set(endpointUrl, []);\n        });\n        tripleCountData.forEach((itemResult, i) => {\n            let date = itemResult.date;\n            let endpointUrl = itemResult.endpoint;\n            let triples = itemResult.triples;\n            endpointDataSerieMap.get(endpointUrl).push([date, triples])\n        });\n\n        if (endpointDataSerieMap.size > 0) {\n            let triplesSeries = ChartsUtils.getScatterDataSeriesFromMap(endpointDataSerieMap);\n            return writeFile(Global.getCachedFilenameForRunset(runsetId, triplesEchartOptionFilename), JSON.stringify(ChartsUtils.getTimeScatterOption(\"Size of the datasets\", triplesSeries))).then(() => {\n                Logger.info(\"Triple chart data for\", runsetId, \" generated\");\n            });\n\n        } else {\n            return Promise.reject(\"No data to generate the triple graph for \" + runsetId);\n        }\n    }).catch((error) => {\n        Logger.error(\"Error during triple data reading\", error)\n    });\n\n}\n\nexport function classesEchartsOption(runsetId: string): Promise<void> {\n    return readFile(Global.getCachedFilenameForRunset(runsetId, DataCache.classCountFilename), \"utf-8\").then(classesCountRawData => {\n        classCountData = JSON.parse(classesCountRawData);\n        // Scatter plot of the number of classes through time\n        let endpointDataSerieMap = new Map();\n        classCountData.forEach((itemResult, i) => {\n            let endpointUrl = itemResult.endpoint;\n            endpointDataSerieMap.set(endpointUrl, []);\n        });\n        classCountData.forEach((itemResult, i) => {\n            let date = itemResult.date;\n            let endpointUrl = itemResult.endpoint;\n            let classes = itemResult.classes;\n            endpointDataSerieMap.get(endpointUrl).push([date, classes])\n        });\n\n        if (endpointDataSerieMap.size > 0) {\n            let classesSeries = ChartsUtils.getScatterDataSeriesFromMap(endpointDataSerieMap);\n            return writeFile(Global.getCachedFilenameForRunset(runsetId, classesEchartOptionFilename), JSON.stringify(ChartsUtils.getTimeScatterOption(\"Number of classes in the datasets\", classesSeries))).then(() => {\n                Logger.info(\"Class chart data for\", runsetId, \" generated\");\n            });\n\n        } else {\n            return Promise.reject(\"No data to generate the classes graph for \" + runsetId);\n        }\n    }).catch((error) => {\n        Logger.error(\"Error during classes data reading\", error)\n    });\n\n}\n\nexport function propertiesEchartsOption(runsetId: string): Promise<void> {\n    return readFile(Global.getCachedFilenameForRunset(runsetId, DataCache.propertyCountFilename), \"utf-8\").then(propertiesCountRawData => {\n        propertyCountData = JSON.parse(propertiesCountRawData);\n        // Scatter plot of the number of classes through time\n        let endpointDataSerieMap = new Map();\n        propertyCountData.forEach((itemResult, i) => {\n            let endpointUrl = itemResult.endpoint;\n            endpointDataSerieMap.set(endpointUrl, []);\n        });\n        propertyCountData.forEach((itemResult, i) => {\n            let date = itemResult.date;\n            let endpointUrl = itemResult.endpoint;\n            let properties = itemResult.properties;\n            endpointDataSerieMap.get(endpointUrl).push([date, properties])\n        });\n\n        if (endpointDataSerieMap.size > 0) {\n            let propertiesSeries = ChartsUtils.getScatterDataSeriesFromMap(endpointDataSerieMap);\n            return writeFile(Global.getCachedFilenameForRunset(runsetId, propertiesEchartOptionFilename), JSON.stringify(ChartsUtils.getTimeScatterOption(\"Number of properties in the datasets\", propertiesSeries))).then(() => {\n                Logger.info(\"Property chart data for\", runsetId, \" generated\");\n            });\n\n        } else {\n            return Promise.reject(\"No data to generate the properties graph for \" + runsetId);\n        }\n    }).catch((error) => {\n        Logger.error(\"Error during properties data reading\", error)\n    });\n}\n\nexport function shortUrisEchartsOption(runsetId: string): Promise<void> {\n    return readFile(Global.getCachedFilenameForRunset(runsetId, DataCache.shortUriDataFilename), \"utf-8\").then(shortUrisCountRawData => {\n        shortUrisData = JSON.parse(shortUrisCountRawData);\n        // Scatter plot of the number of classes through time\n        let endpointDataSerieMap = new Map();\n        shortUrisData.forEach((itemResult, i) => {\n            let endpointUrl = itemResult.endpoint;\n            endpointDataSerieMap.set(endpointUrl, []);\n        });\n        shortUrisData.forEach((itemResult, i) => {\n            let date = itemResult.date;\n            let endpointUrl = itemResult.endpoint;\n            let shortUris = itemResult.measure;\n            endpointDataSerieMap.get(endpointUrl).push([date, shortUris])\n        });\n\n        if (endpointDataSerieMap.size > 0) {\n            let shortUrisSeries = ChartsUtils.getScatterDataSeriesFromMap(endpointDataSerieMap);\n            return writeFile(Global.getCachedFilenameForRunset(runsetId, shortUrisEchartOptionFilename), JSON.stringify(ChartsUtils.getTimeScatterOption(\"Proportion of short URIs in the datasets\", shortUrisSeries))).then(() => {\n                Logger.info(\"Short URIs chart data for\", runsetId, \" generated\");\n            });\n\n        } else {\n            return Promise.reject(\"No data to generate the Short URIs graph for \" + runsetId);\n        }\n    }).catch((error) => {\n        Logger.error(\"Error during Short URIs data reading\", error)\n    });\n}\n\nexport function rdfDataStructuresEchartsOption(runsetId: string): Promise<void> {\n    return readFile(Global.getCachedFilenameForRunset(runsetId, DataCache.rdfDataStructureDataFilename), \"utf-8\").then(rdfDataStructuresCountRawData => {\n        rdfDataStructureData = JSON.parse(rdfDataStructuresCountRawData);\n        // Scatter plot of the number of classes through time\n        let endpointDataSerieMap = new Map();\n        rdfDataStructureData.forEach((itemResult, i) => {\n            let endpointUrl = itemResult.endpoint;\n            endpointDataSerieMap.set(endpointUrl, []);\n        });\n        rdfDataStructureData.forEach((itemResult, i) => {\n            let date = itemResult.date;\n            let endpointUrl = itemResult.endpoint;\n            let rdfDatastructures = itemResult.measure;\n            endpointDataSerieMap.get(endpointUrl).push([date, rdfDatastructures])\n        });\n\n        if (endpointDataSerieMap.size > 0) {\n            let rdfDataStructuresSeries = ChartsUtils.getScatterDataSeriesFromMap(endpointDataSerieMap);\n            return writeFile(Global.getCachedFilenameForRunset(runsetId, rdfDataStructuresEchartOptionFilename), JSON.stringify(ChartsUtils.getTimeScatterOption(\"Proportion of RDF data structures in the datasets\", rdfDataStructuresSeries))).then(() => {\n                Logger.info(\"RDF data structures chart data generated\");\n            });\n\n        } else {\n            return Promise.reject(\"No data to generate the RDF data structures chart for \" + runsetId);\n        }\n    }).catch((error) => {\n        Logger.error(\"Error during RDF data structures data reading\", error)\n    });\n}\n\nexport function readableLabelsEchartsOption(runsetId: string): Promise<void> {\n    return readFile(Global.getCachedFilenameForRunset(runsetId, DataCache.readableLabelDataFilename), \"utf-8\").then(readableLabelsCountRawData => {\n        readableLabelData = JSON.parse(readableLabelsCountRawData);\n        // Scatter plot of the number of classes through time\n        let endpointDataSerieMap = new Map();\n        readableLabelData.forEach((itemResult, i) => {\n            let endpointUrl = itemResult.endpoint;\n            endpointDataSerieMap.set(endpointUrl, []);\n        });\n        readableLabelData.forEach((itemResult, i) => {\n            let date = itemResult.date;\n            let endpointUrl = itemResult.endpoint;\n            let readableLabels = itemResult.measure;\n            endpointDataSerieMap.get(endpointUrl).push([date, readableLabels])\n        });\n\n        if (endpointDataSerieMap.size > 0) {\n            let readableLabelsSeries = ChartsUtils.getScatterDataSeriesFromMap(endpointDataSerieMap);\n            return writeFile(Global.getCachedFilenameForRunset(runsetId, readableLabelsEchartOptionFilename), JSON.stringify(ChartsUtils.getTimeScatterOption(\"Proportion of resources with readable labels in the datasets\", readableLabelsSeries))).then(() => {\n                Logger.info(\"Readable labels chart data for\", runsetId, \" generated\");\n            });\n\n        } else {\n            return Promise.reject(\"No data to generate the readable labels chart for \" + runsetId);\n        }\n    }).catch((error) => {\n        Logger.error(\"Error during RDF data structures data reading for\", runsetId, \"\", error)\n    });\n}\n\nexport function blankNodesEchartsOption(runsetId: string): Promise<void> {\n    return readFile(Global.getCachedFilenameForRunset(runsetId, DataCache.blankNodesDataFilename), \"utf-8\").then(blankNodesCountRawData => {\n        blankNodesData = JSON.parse(blankNodesCountRawData);\n        // Scatter plot of the number of classes through time\n        let endpointDataSerieMap = new Map();\n        blankNodesData.forEach((itemResult, i) => {\n            let endpointUrl = itemResult.endpoint;\n            endpointDataSerieMap.set(endpointUrl, []);\n        });\n        blankNodesData.forEach((itemResult, i) => {\n            let date = itemResult.date;\n            let endpointUrl = itemResult.endpoint;\n            let blankNodes = itemResult.measure;\n            endpointDataSerieMap.get(endpointUrl).push([date, blankNodes])\n        });\n\n        if (endpointDataSerieMap.size > 0) {\n            let blankNodesSeries = ChartsUtils.getScatterDataSeriesFromMap(endpointDataSerieMap);\n            return writeFile(Global.getCachedFilenameForRunset(runsetId, blankNodesEchartOptionFilename), JSON.stringify(ChartsUtils.getTimeScatterOption(\"Proportion of blank nodes in the datasets\", blankNodesSeries))).then(() => {\n                Logger.info(\"Blank nodes chart data for\", runsetId, \" generated\");\n            });\n\n        } else {\n            return Promise.reject(\"No data to generate the blank nodes chart for \" + runsetId);\n        }\n    }).catch((error) => {\n        Logger.error(\"Error during blank nodes data reading\", error)\n    });\n}\n\nexport function datasetDescriptionEchartsOption(runsetId) {\n    Logger.info(\"Dataset description chart data for\", runsetId, \" generation started\")\n    return readFile(Global.getCachedFilenameForRunset(runsetId, DataCache.datasetDescriptionDataFilename), \"utf-8\").then(datasetDescriptionRawData => {\n        datasetDescriptionData = JSON.parse(datasetDescriptionRawData);\n\n        let whoDataScore = 0;\n        let licenseDataScore = 0;\n        let timeDataScore = 0;\n        let sourceDataScore = 0;\n\n        datasetDescriptionData.forEach(dataItem => {\n            let who = dataItem.who;\n            if (who) {\n                whoDataScore++;\n            }\n            let license = dataItem.license;\n            if (license) {\n                licenseDataScore++;\n            }\n            let time = dataItem.time;\n            if (time) {\n                timeDataScore++;\n            }\n            let source = dataItem.source;\n            if (source) {\n                sourceDataScore++;\n            }\n        });\n\n\n        let whoTrueDataSerie: echarts.BarSeriesOption = {\n            name: 'Description of author',\n            type: 'bar',\n            stack: 'who',\n            colorBy: 'data',\n            data: [\n                { value: whoDataScore, name: 'Presence of the description of creator/owner/contributor' },\n            ]\n        };\n        if (whoDataScore > 0) {\n            whoTrueDataSerie.label = {\n                show: true,\n                formatter: '{c} endpoints with author description'\n            }\n        };\n        let whoFalseDataSerie: echarts.BarSeriesOption = {\n            name: 'Description of author',\n            type: 'bar',\n            stack: 'who',\n            colorBy: 'data',\n            data: [\n                { value: (datasetDescriptionData.length - whoDataScore), name: 'Absence of the description of creator/owner/contributor' },\n            ]\n        };\n        if ((datasetDescriptionData.length - whoDataScore) > 0) {\n            whoFalseDataSerie.label = {\n                show: true,\n                formatter: '{c} endpoints without author description'\n            }\n        };\n        let licenseTrueDataSerie: echarts.BarSeriesOption = {\n            name: 'Licensing description',\n            type: 'bar',\n            stack: 'license',\n            colorBy: 'data',\n            data: [\n                { value: licenseDataScore, name: 'Presence of licensing information' },\n            ]\n        };\n        if (licenseDataScore > 0) {\n            licenseTrueDataSerie.label = {\n                show: true,\n                formatter: '{c} endpoints with licensing description'\n            }\n        }\n        let licenseFalseDataSerie: echarts.BarSeriesOption = {\n            name: 'Licensing description',\n            type: 'bar',\n            stack: 'license',\n            colorBy: 'data',\n            data: [\n                { value: (datasetDescriptionData.length - licenseDataScore), name: 'Absence of licensing description' },\n            ]\n        };\n        if ((datasetDescriptionData.length - licenseDataScore) > 0) {\n            licenseFalseDataSerie.label = {\n                show: true,\n                formatter: '{c} endpoints without licensing description'\n            }\n        }\n        let timeTrueDataSerie: echarts.BarSeriesOption = {\n            name: 'Time related description of the creation of the dataset',\n            type: 'bar',\n            stack: 'time',\n            colorBy: 'data',\n            data: [\n                { value: timeDataScore, name: 'Presence of time-related information' },\n            ]\n        };\n        if (timeDataScore > 0) {\n            timeTrueDataSerie.label = {\n                show: true,\n                formatter: '{c} endpoints with time-related description'\n            }\n        }\n        let timeFalseDataSerie: echarts.BarSeriesOption = {\n            name: 'Time related description of creation of the dataset',\n            type: 'bar',\n            stack: 'time',\n            colorBy: 'data',\n            data: [\n                { value: (datasetDescriptionData.length - timeDataScore), name: 'Absence of time-related description' },\n            ]\n        };\n        if ((datasetDescriptionData.length - timeDataScore) > 0) {\n            timeFalseDataSerie.label = {\n                show: true,\n                formatter: '{c} endpoints without time-related description'\n            }\n        }\n        let sourceTrueDataSerie: echarts.BarSeriesOption = {\n            name: 'Description of the source or the process at the origin of the dataset',\n            type: 'bar',\n            stack: 'source',\n            colorBy: 'data',\n            data: [\n                { value: sourceDataScore, name: 'Presence of description of the origin of the dataset' },\n            ]\n        };\n        if (sourceDataScore > 0) {\n            sourceTrueDataSerie.label = {\n                show: true,\n                formatter: '{c} endpoints with source description'\n            }\n        }\n        let sourceFalseDataSerie: echarts.BarSeriesOption = {\n            name: 'Description of the source or the process at the origin of the dataset',\n            type: 'bar',\n            stack: 'source',\n            colorBy: 'data',\n            data: [\n                { value: (datasetDescriptionData.length - sourceDataScore), name: 'Absence of description of the origin of the dataset' },\n            ]\n        };\n        if ((datasetDescriptionData.length - sourceDataScore) > 0) {\n            sourceFalseDataSerie.label = {\n                show: true,\n                formatter: '{c} endpoints without source description'\n            }\n        }\n        let datasetDescriptionEchartOption = {\n            title: {\n                text: 'Dataset description features in all endpoints',\n                left: 'center'\n            },\n            tooltip: {\n                confine: true\n            },\n            xAxis: {\n                type: 'value',\n                max: 'dataMax',\n            },\n            yAxis: {\n                type: 'category',\n                axisLabel: {\n                    formatter: 'Dataset\\n description\\n elements',\n                    overflow: 'breakAll'\n                }\n            },\n            legend: {\n                left: 'left',\n                show: false\n            },\n            series: [whoTrueDataSerie, whoFalseDataSerie, licenseTrueDataSerie, licenseFalseDataSerie, timeTrueDataSerie, timeFalseDataSerie, sourceTrueDataSerie, sourceFalseDataSerie]\n        };\n        return datasetDescriptionEchartOption;\n    }).then((datasetDescriptionEchartOption) => {\n        let content = JSON.stringify(datasetDescriptionEchartOption);\n        return writeFile(Global.getCachedFilenameForRunset(runsetId, datasetDescriptionEchartOptionFilename), content).then(() => {\n            Logger.info(\"Dataset description chart option for\", runsetId, \" generation ended\");\n            return Promise.resolve();\n        });\n    });\n}\n\n// export function nonFilteredVocabChartOption(runsetId: string): Promise<void> {\n//     this.sparqlesVocabulariesQuery = `SELECT DISTINCT ?endpointUrl ?vocabulary { \n//             GRAPH ?g {\n//                 { ?base <http://www.w3.org/ns/sparql-service-description#endpoint> ?endpointUrl . }\n//                 UNION { ?base <http://rdfs.org/ns/void#sparqlEndpoint> ?endpointUrl . }\n//                 ?metadata <http://ns.inria.fr/kg/index#curated> ?base , ?dataset .\n//                 ?dataset <http://rdfs.org/ns/void#vocabulary> ?vocabulary\n//             }\n//         }\n//         GROUP BY ?endpointUrl ?vocabulary`;\n\n//     let endpointSet = new Set();\n//     let rawVocabSet = new Set();\n//     let rawGatherVocab = new Map();\n//     vocabEndpointData.forEach((item, i) => {\n//         let endpoint = item.endpoint;\n//         let vocabularies = item.vocabularies;\n//         if (vocabularies.length < numberOfVocabulariesLimit) {\n//             endpointSet.add(endpoint);\n//             vocabularies.forEach(vocab => {\n//                 rawVocabSet.add(vocab);\n//             })\n//             if (!rawGatherVocab.has(endpoint)) {\n//                 rawGatherVocab.set(endpoint, new Set());\n//             }\n//             rawGatherVocab.set(endpoint, vocabularies);\n//         }\n//     });\n\n//     let jsonRawVocabNodes = new Set();\n//     let jsonRawVocabLinks = new Set();\n\n//     endpointSet.forEach(item => {\n//         jsonRawVocabNodes.add({ name: item, category: 'Endpoint', symbolSize: 5 });\n//     });\n//     rawVocabSet.forEach(item => {\n//         jsonRawVocabNodes.add({ name: item, category: 'Vocabulary', symbolSize: 5 })\n//     });\n//     rawGatherVocab.forEach((endpointVocabs, endpointUrl, map1) => {\n//         endpointVocabs.forEach((vocab, i) => {\n//             jsonRawVocabLinks.add({ source: endpointUrl, target: vocab })\n//         });\n//     });\n\n\n//     if (jsonRawVocabNodes.size > 0 && jsonRawVocabLinks.size > 0) {\n//         let resultOption = ChartsUtils.getForceGraphOption('Endpoints and vocabularies without filtering', [\"Vocabulary\", \"Endpoint\"], [...jsonRawVocabNodes], [...jsonRawVocabLinks]);\n//         return writeFile(Global.getCachedFilenameForRunset(runsetId, vocabEndpointEchartsOptionFilename), JSON.stringify(resultOption)).then(() => {\n//             Logger.info(\"Endpoints and vocabularies without filtering chart data generated\");\n//             return;\n//         });\n//     } else {\n//         return Promise.reject(\"No data to generate the non filtered vocabularies chart\");\n//     }\n// }\n\nexport function totalRuntimeEchartsOption(runtimeId: string) {\n    Logger.info(\"Total runtime chart settings generation started\");\n    return readFile(Global.getCachedFilenameForRunset(runtimeId, DataCache.totalRuntimeDataFilename), \"utf-8\").then(totalRuntimeRawData => {\n        let totalRuntimeData = JSON.parse(totalRuntimeRawData);\n        let runtimeDataSerie = [];\n        totalRuntimeData.forEach((itemResult, i) => {\n            let graph = itemResult.graph;\n            let start = Global.parseDate(itemResult.start);\n            let end = Global.parseDate(itemResult.end);\n            let endpoint = itemResult.endpoint;\n            let date = Global.parseDate(itemResult.date);\n            let runtime = dayjs.duration(itemResult.runtime);\n            runtimeDataSerie.push([date, runtime, endpoint])\n        });\n        let runtimeSerie = {\n            name: \"Runtime in seconds\",\n            label: 'show',\n            symbolSize: 5,\n            data: runtimeDataSerie.map(a => [a[0].toDate(), a[1].asSeconds()]),\n            tooltip: {\n                show: true,\n                formatter: function (value) {\n                    let source = runtimeDataSerie.filter(a => a[0].isSame(dayjs(value.value[0])))[0];\n                    let runtime = source[1];\n                    let endpoint = source[2];\n\n                    let tooltip = endpoint + \" <br/>\" + runtime.humanize();\n                    return tooltip;\n                }\n            },\n            type: 'scatter'\n        };\n        let totalRuntimeChartOption = ChartsUtils.getTimeScatterOption(\"Runtime of the framework for each run (in seconds)\", [runtimeSerie]);\n        return writeFile(Global.getCachedFilenameForRunset(runtimeId, totalRuntimeEchartsOptionFilename), JSON.stringify(totalRuntimeChartOption)).then(() => {\n            Logger.info(\"Total runtime chart settings generated\");\n        });\n\n    }).catch((error) => {\n        Logger.error(\"Error during total runtime data reading\", error)\n    });\n}","import { EChartsOption } from \"echarts\";\n\n\nexport function getForceGraphOption(title, legendData, dataNodes, dataLinks): EChartsOption {\n    let categories: any[] = [];\n    legendData.forEach((item, i) => {\n        categories.push({ name: item });\n    });\n    return {\n        title: {\n            text: title,\n            top: 'top',\n            left: 'center'\n        },\n        tooltip: {\n            show: true,\n            confine: true,\n        },\n        legend: {\n                data: legendData,\n                top: 'bottom',\n            } ,\n        series: [\n            {\n                type: 'graph',\n                layout: 'force',\n                data: dataNodes,\n                links: dataLinks,\n                categories: categories,\n                roam: true,\n                draggable: true,\n                label: {\n                    show: false\n                },\n                force: {\n                    repulsion: 50\n                }\n            }\n        ]\n    };\n}\n\nexport function getCircularGraphOption(title, legendData, dataNodes, dataLinks): EChartsOption {\n    let categories: any[] = [];\n    legendData.forEach((item, i) => {\n        categories.push({ name: item });\n    });\n    return {\n        title: {\n            text: title,\n            top: 'top',\n            left: 'center'\n        },\n        tooltip: {\n            show: true,\n            confine: true,\n        },\n        legend: {\n                data: legendData,\n                top: 'bottom',\n            } ,\n        series: [\n            {\n                type: 'graph',\n                layout: 'circular',\n                circular: {\n                    rotateLabel: true\n                },\n                data: dataNodes,\n                links: dataLinks,\n                categories: categories,\n                roam: true,\n                draggable: true,\n                label: {\n                    position: 'right',\n                    formatter: '{b}'\n                },\n                lineStyle: {\n                    color: 'source',\n                    curveness: 0.3\n                }\n            }\n        ]\n    };\n}\n\nexport function getCategoryScatterOption(title, categories, series): EChartsOption {\n    return {\n        title: {\n            left: 'center',\n            text: title,\n        },\n        xAxis: {\n            type: 'category',\n            data: categories,\n            axisLabel: {\n                show: true,\n                interval: 0,\n                rotate: 27\n            }\n        },\n        yAxis: {\n        },\n        series: series,\n        tooltip: {\n            show: true\n        }\n    };\n}\n\nexport function getTimeScatterOption(title, series): EChartsOption {\n    return {\n        title: {\n            left: 'center',\n            text: title,\n        },\n        xAxis: {\n            type: 'time',\n            axisLabel: {\n                show: true,\n                interval: 0,\n                rotate: 27\n            }\n        },\n        yAxis: {\n        },\n        series: series,\n        tooltip: {\n            show: true\n        }\n    };\n}\n\nexport function getScatterDataSeriesFromMap(dataMap: Map<string, string[]>): any[] {\n    let series: any[] = [];\n    dataMap.forEach((value, key, map) => {\n        let chartSerie: any = {\n            name: key,\n            label: { show: false },\n            symbolSize: 5,\n            data: [...new Set(value)].filter(a => a[0] !== null && a[0] !== undefined).sort((a, b) => a[0].localeCompare(b[0])),\n            type: 'line'\n        };\n\n        series.push(chartSerie);\n    });\n    return series;\n}"],"names":[],"version":3,"file":"index.js.map"}